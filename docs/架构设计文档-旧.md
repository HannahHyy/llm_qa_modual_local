# COMBINE_LLM 架构重构设计文档

## 版本：2.0（重构版）
## 更新日期：2025-12-18

---

## 目录
1. [重构目标与原则](#1-重构目标与原则)
2. [新架构设计](#2-新架构设计)
3. [模块划分与职责](#4-模块划分与职责)
4. [技术选型](#5-技术选型)
5. [数据流设计](#6-数据流设计)
6. [配置管理方案](#7-配置管理方案)
7. [日志与监控方案](#8-日志与监控方案)
8. [部署架构](#9-部署架构)
9. [实施计划](#10-实施计划)

---

## 1. 重构目标与原则

### 1.1 核心目标
- **高内聚-低耦合**：各模块职责单一、边界清晰
- **可维护性**：代码结构清晰、易于理解和修改
- **可扩展性**：支持新功能平滑接入
- **可测试性**：各模块独立可测
- **生产就绪**：完善的配置、日志、监控、错误处理

### 1.2 设计原则
- **单一职责原则（SRP）**：每个模块只负责一个功能领域
- **依赖倒置原则（DIP）**：面向接口编程，不依赖具体实现
- **开闭原则（OCP）**：对扩展开放，对修改关闭
- **配置外部化**：所有配置通过环境变量或配置文件管理
- **统一错误处理**：全局异常处理和降级策略

---

## 2. 新架构设计

### 2.1 架构分层

采用经典的**分层+模块化架构**：
API层 → 应用服务层 → 领域逻辑层 → 基础设施层
```
┌─────────────────────────────────────────────────────────────┐
│                    API Gateway Layer                        │
│                  (FastAPI Application)                      │
│              routes/ - 路由定义与请求验证                    │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                   Service Layer (核心业务层)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Chat Service │  │ Session Mgmt │  │ Intent Router│       │
│  │  对话服务     │  │  会话管理     │  │  意图路由     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                  Domain Layer (领域逻辑层)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ Intent Parser│  │ Knowledge     │  │ Knowledge     │     │
│  │  意图解析     │  │ Retriever    │  │ Matcher      │      │
│  │              │  │  知识检索     │  │  知识匹配     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│  ┌──────────────┐  ┌──────────────┐                        │
│  │ Prompt Builder│ │ Memory Mgmt  │                        │
│  │  提示词构建   │  │  记忆管理     │                        │
│  └──────────────┘  └──────────────┘                        │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│              Infrastructure Layer (基础设施层)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ LLM Client   │  │ ES Client    │  │ Neo4j Client │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Redis Client │  │ MySQL Client │  │ Embedding Svc│     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    Cross-Cutting Concerns                   │
│             (日志、监控、配置、错误处理、限流、鉴权)           │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 目录结构设计

```
combine_llm/
├── config/                          # 配置管理
│   ├── __init__.py
│   ├── settings.py                  # 统一配置类（基于pydantic）
│   ├── .env.example                 # 环境变量模板
│   └── logging_config.py            # 日志配置
│
├── core/                            # 核心基础设施
│   ├── __init__.py
│   ├── logging.py                   # 统一日志管理
│   ├── exceptions.py                # 自定义异常类
│   ├── dependencies.py              # FastAPI依赖注入
│   └── middleware.py                # 中间件（日志、限流、鉴权）
│
├── infrastructure/                  # 基础设施层（数据库、外部服务）
│   ├── __init__.py
│   ├── clients/
│   │   ├── __init__.py
│   │   ├── llm_client.py           # LLM客户端（统一）
│   │   ├── elasticsearch.py        # ES客户端
│   │   ├── neo4j_client.py         # Neo4j客户端
│   │   ├── redis_client.py         # Redis客户端
│   │   ├── mysql_client.py         # MySQL客户端
│   │   └── embedding_client.py     # Embedding服务客户端
│   └── repositories/                # 数据访问层（Repository模式）
│       ├── __init__.py
│       ├── base.py                  # 基础Repository
│       ├── session_repository.py    # 会话数据访问
│       ├── message_repository.py    # 消息数据访问
│       └── knowledge_repository.py  # 知识库数据访问
│
├── domain/                          # 领域逻辑层
│   ├── __init__.py
│   ├── models/                     # 领域模型（数据结构）
│   │   ├── __init__.py
│   │   ├── intent.py               # 意图模型
│   │   ├── knowledge.py            # 知识模型
│   │   ├── message.py              # 消息模型
│   │   └── session.py              # 会话模型
│   ├── services/                   # 领域服务（核心业务逻辑）
│   │   ├── __init__.py
│   │   ├── intent_parser/          # 意图解析服务
│   │   │   ├── __init__.py
│   │   │   ├── base.py             # 意图解析基类
│   │   │   ├── es_intent_parser.py # ES意图解析器
│   │   │   └── neo4j_intent_parser.py # Neo4j意图解析器
│   │   ├── retrieval/               # 知识检索服务
│   │   │   ├── __init__.py
│   │   │   ├── base.py             # 检索器基类
│   │   │   ├── es_retriever.py     # ES检索器
│   │   │   ├── neo4j_retriever.py  # Neo4j检索器
│   │   │   └── hybrid_retriever.py # 混合检索器
│   │   ├── knowledge_matcher.py    # 知识匹配服务
│   │   ├── prompt_builder.py       # 提示词构建服务
│   │   └── memory_service.py       # 记忆管理服务
│   └── strategies/                  # 策略模式（检索策略、路由策略）
│       ├── __init__.py
│       ├── intent_routing.py       # 意图路由策略
│       └── retrieval_strategy.py   # 检索策略
│
├── application/                    # 应用服务层（编排领域服务）
│   ├── __init__.py
│   ├── chat_service.py             # 对话服务（核心编排）
│   ├── session_service.py          # 会话管理服务
│   └── streaming_service.py        # 流式响应服务
│
├── api/                             # API层（路由与请求处理）
│   ├── __init__.py
│   ├── v1/
│   │   ├── __init__.py
│   │   ├── chat.py                 # 对话API
│   │   ├── sessions.py             # 会话管理API
│   │   └── health.py               # 健康检查API
│   ├── schemas/                     # 请求/响应模型（Pydantic）
│   │   ├── __init__.py
│   │   ├── chat.py
│   │   └── session.py
│   └── dependencies.py              # API层依赖注入
│
├── scripts/                        # 脚本工具
│   ├── init_database.py            # 数据库初始化
│   ├── import_knowledge.py         # 知识导入
│   └── migrate.py                  # 数据迁移
│
├── tests/                           # 测试
│   ├── unit/                        # 单元测试
│   ├── integration/                 # 集成测试
│   └── fixtures/                    # 测试夹具
│
├── docs/                           # 文档
│   ├── architecture.md             # 架构说明
│   ├── api.md                      # API文档
│   └── deployment.md               # 部署文档
│
├── main.py                          # 应用入口
├── requirements.txt                 # 依赖管理
├── .env.example                     # 环境变量示例
├── .gitignore
├── pytest.ini                       # pytest配置
└── README.md
```

---

## 3. 模块划分与职责

### 3.1 API层（api/）
**职责**：接收HTTP请求、参数验证、返回响应
**原则**：薄层，不包含业务逻辑

#### 主要模块：
- **chat.py**：对话相关API（/api/v1/chat/stream）
- **sessions.py**：会话管理API（CRUD）
- **health.py**：健康检查、服务状态

**关键点**：
- 使用Pydantic进行请求验证
- 统一的错误响应格式
- 依赖注入服务层

### 3.2 应用服务层（application/）
**职责**：编排领域服务，实现完整的业务流程
**原则**：协调者角色，不包含领域逻辑

#### 主要模块：
- **chat_service.py**：
  - 编排对话流程（意图路由 → 检索 → 生成 → 存储）
  - 处理三种查询模式（ES/Neo4j/混合）
  - 异常处理与降级

- **session_service.py**：
  - 会话生命周期管理
  - 同步Redis、MySQL、ES状态

- **streaming_service.py**：
  - 流式响应生成
  - 标签格式化（<think>、<data>、<knowledge>）
  - 缓冲与错误恢复

### 3.3 领域逻辑层（domain/）
**职责**：核心业务逻辑，独立于框架和外部服务
**原则**：可独立测试、纯业务逻辑

#### 主要模块组：

**1. 意图解析（intent_parser/）**
- **base.py**：
  ```python
  class BaseIntentParser(ABC):
      @abstractmethod
      async def parse(self, query: str, history: List[Message]) -> Intent:
          pass
  ```
- **es_intent_parser.py**：法规标准意图解析
- **neo4j_intent_parser.py**：业务图谱意图解析

**2. 知识检索（retrieval/）**
- **base.py**：
  ```python
  class BaseRetriever(ABC):
      @abstractmethod
      async def retrieve(self, intent: Intent) -> List[Knowledge]:
          pass
  ```
- **es_retriever.py**：ES检索（BM25+向量）
- **neo4j_retriever.py**：Neo4j图查询
- **hybrid_retriever.py**：混合检索协调器

**3. 其他服务**
- **knowledge_matcher.py**：BM25匹配LLM输出与检索结果
- **prompt_builder.py**：构建完整提示词
- **memory_service.py**：长期记忆检索与更新

### 3.4 基础设施层（infrastructure/）
**职责**：封装外部系统交互（数据库、API）
**原则**：可替换、接口统一

#### 客户端（clients/）：
所有客户端实现统一接口，支持：
- 连接池管理
- 重试机制
- 超时控制
- 健康检查

**示例**：
```python
class LLMClient:
    async def stream_chat(self, prompt: str, **kwargs) -> AsyncGenerator[str, None]:
        """流式对话"""

    async def health_check(self) -> bool:
        """健康检查"""
```

#### 仓储层（repositories/）：
实现Repository模式，统一数据访问接口：
```python
class SessionRepository:
    async def create(self, session: Session) -> str:
        """创建会话（同步Redis、MySQL、ES）"""

    async def get_messages(self, session_id: str) -> List[Message]:
        """获取消息（Redis优先，ES备用）"""
```

### 3.5 核心基础设施（core/）
**职责**：横切关注点（日志、异常、中间件）

#### 主要模块：
- **logging.py**：
  - 统一日志配置（基于loguru）
  - 结构化日志（JSON格式）
  - 日志级别、轮转、压缩

- **exceptions.py**：
  - 自定义异常类层次
  - 错误码定义
  - 异常转HTTP响应

- **middleware.py**：
  - 请求日志中间件
  - 限流中间件
  - 鉴权中间件（可选）

---

## 4. 技术选型

### 4.1 核心技术栈
| 组件 | 技术选型 | 版本 | 说明 |
|-----|---------|------|------|
| Web框架 | FastAPI | 0.115+ | 异步、高性能、类型提示 |
| 异步运行时 | uvicorn | 0.30+ | ASGI服务器 |
| 数据验证 | Pydantic | 2.10+ | 配置管理、请求验证 |
| 日志 | loguru | 0.7+ | 简洁的日志API |
| HTTP客户端 | httpx | 0.27+ | 异步HTTP客户端 |
| Redis客户端 | redis-py | 5.0+ | 支持异步 |
| MySQL客户端 | aiomysql | 0.2+ | 异步MySQL |
| ES客户端 | elasticsearch | 8.15+ | 官方客户端 |
| Neo4j客户端 | neo4j | 5.26+ | 官方驱动 |
| 测试框架 | pytest | 8.3+ | 单元测试、集成测试 |
| 依赖注入 | FastAPI Depends | - | 内置依赖注入 |

### 4.2 开发工具
- **代码格式化**：black、isort
- **类型检查**：mypy
- **代码质量**：pylint、flake8
- **API文档**：FastAPI自动生成（Swagger/ReDoc）

### 4.3 监控与观测
- **性能监控**：Prometheus + Grafana
- **链路追踪**：Langfuse（LLM调用）
- **健康检查**：自定义健康检查端点

---

## 5. 数据流设计

### 5.1 完整对话流程

- 创建会话:
  1) API 请求 -> FastAPI
  2) FastAPI -> 写入 MySQL（会话元数据表）
  3) FastAPI -> 更新 Redis：chat:{user_id}:sessions（Hash）
  4) FastAPI -> 更新 ES 历史会话数据表

- 流式对话:
  1) 用户查询 -> 前端界面
  2) 前端 -> 后端聊天处理器（发送 user_id, session_id, query）
  3) 聊天处理器 -> Redis 获取历史记录（优先从缓存获取）
  4) Redis 缓存未命中 -> ES获取历史记录
  5) 聊天处理器获得 history_msgs 后 -> 并行执行两种检索：
     - 知识检索：从 ES 知识库 + Neo4j 知识图谱检索相关知识
     - 长期记忆检索：从 ES 长期记忆索引按 user_id 检索相似对话摘要
  6) 构建提示器收集：history_msgs + query + knowledge + long_memory
  7) 构造完整 Prompt -> 调用 LLM -> 流式返回（结果 + 知识）
  8) 聊天处理器 -> 流式响应给前端
  9) 同步存储：将对话记录同时写入 Redis 和 ES

- 长期记忆更新（异步后台任务）:
  1) 会话结束时 -> 摘要器从 ES 历史记录中读取完整会话
  2) 摘要器生成会话摘要（包含 user_id, session_id, 创建时间）
  3) 摘要器 -> 将摘要写入 ES 长期记忆索引
---

以下是 `/api/chat/stream` 接口处理一次用户提问的详细工作流：

1. **接收请求**：后端收到携带 `user_id` 和 `session_id` 的 POST 请求。
2. **加载短期上下文**：先从 Redis 中（找不到再找ES）获取该会话（`user_id` + `session_id`）的 N 条消息，(没读到再从ES索引表里读)构成 `CURRENT_CHAT_HISTORY`。
   `输出`：`USER_QUERY`+ `CURRENT_CHAT_HISTORY`
3.  **用户意图解析**：使用提示词（可改参数）的方式，根据上述Context拼接，调用一次大模型，确认接下来的路径：
    a. 输入问题改写：这部分需涉及`同义词扩展`、`相似词`和`不同语法表述`；
    b. 结构化意图解析:细化问题的每个意图部分；
    c. 对于每个意图，进行`标准识别`，`实体提取`，`查询重写`，`检索策略判定`。生成两部分内容：
      c.1 流式输出，作为<think></think>内容展示再前端
      c.2 json输出，体现意图数量，每个意图的解析结果，origin_query，history_msgs传给4.中的检索
   `输入`：`SYSTEM_PROMPT`+`USER_QUERY`+ `CURRENT_CHAT_HISTORY`
   `输出`： 详见retrieval_server/intent_return1.json & intent_return2.json
4.  **同步检索以下知识库和长期记忆**
  4.1 **检索标准知识库ES+Neo4j**：
    a.  **向量/全文检索**：在 Elasticsearch 的 `kb_vector_store` 索引中，执行一个结合了多种策略的查询：
        i.  **Vector Search**: 基于问题 Embedding 找到语义相关的法规条文。
        ii. **Keyword & Metadata Filter**: 结合问题中的关键词和实体信息进行过滤。
      **ES检索器(es_retriever.py)输入输出格式**：
      `输入`：上述意图解析结果（Intent对象列表）
      `输出`：
      retrieval_results=[
          RetrievalResult(
              clause_key_en='ck_a1b2c3d4e5f6',  # ES检索块唯一标识
              content='应建立物理访问控制策略，对进入机房的人员进行身份验证...',
              source_standard='信息安全技术网络安全等级保护基本要求',
              identifier='GB/T 22239-2019',
              requirement_item='物理访问控制',
              section_levels={'level1': '物理和环境安全', 'level2': '物理访问控制', 'level3': '', 'level4': '', 'level5': ''},
              applicability_level='第三级',
              score=0.856,  # 检索相似度值
              retrieval_path='hybrid_combined',  # 检索路径：keyword_search/semantic_search/hybrid_search/hybrid_combined
              related_entities=['防火墙', '访问控制']
          )
      ]
    b.  **图谱检索-**：后续增加。
    c.  形成富有上下文的 `KNOWLEDGE_CONTEXT`。
  4.2 **检索长期记忆 (Memory Retrieval)**：
      a.  计算用户当前问题的 Embedding。
      b.  在 Elasticsearch 的 `user_memory` 索引中，执行一个混合查询：Filter: `user_id` = `{current_user_id}`
      c.  Vector Search: 基于 `query_embedding` 查找语义最相似的历史提问。
      d.  获取 Top-K 条结果，按时间或满意度排序，格式化为 `MEMORY_CONTEXT`。
6.  **构造 Prompt 并调用 LLM**：
    输入：`SYSTEM_PROMPT`+`USER_QUERY` +`CURRENT_CHAT_HISTORY`+`MEMORY_CONTEXT`+ `分析出的每个意图相关的KNOWLEDGE_CONTEXT`,组合成最终的 Prompt。
    输出：调用大模型（如 `deepseek、Qwen`），并通过 Langfuse 记录完整的 trace。
7.  **流式输出**：将模型生成的回答逐块通过 SSE (Server-Sent Events) 返回给前端。
8.  **短期记忆 - 多轮上下文高速缓存**：一次对话流结束后，将完整的回复同时追加到 Redis 的会话消息列表和ES会话记录里中。
9.  **长期记忆 - 持久化与学习**：用户完成本次对话N个小时内没有再交流之后，触发后台任务，将本次对话的 `query_text`, `query_embedding`, `summary_text` 等信息存入 ES 的 `user_memory` 索引，完成长期记忆的更新。

“检索出来的结果和生成再比较一遍，置信度高再生成”

```
┌─────────────┐
│ 前端发起请求 │
│ POST /chat  │
└──────┬──────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 1. API层（api/v1/chat.py）                           │
│    - 参数验证（Pydantic）                             │
│    - 注入ChatService                                 │
└──────┬──────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 2. 应用服务层（application/chat_service.py）         │
│    ┌──────────────────────────────────────────┐     │
│    │ 2.1 加载会话上下文                        │     │
│    │     SessionService.get_messages()        │     │
│    │     → Redis优先，未命中查ES               │     │
│    └──────────────────────────────────────────┘     │
│    ┌──────────────────────────────────────────┐     │
│    │ 2.2 意图路由决策                          │     │
│    │     IntentRoutingStrategy.route()        │     │
│    │     → 判断使用ES/Neo4j/Hybrid/None       │     │
│    └──────────────────────────────────────────┘     │
│    ┌──────────────────────────────────────────┐     │
│    │ 2.3 根据路由调用对应流程                  │     │
│    │     - ES: _es_flow()                     │     │
│    │     - Neo4j: _neo4j_flow()              │     │
│    │     - Hybrid: _hybrid_flow()            │     │
│    └──────────────────────────────────────────┘     │
└──────┬──────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 3. 领域服务层（domain/services/）                    │
│    ┌──────────────────────────────────────────┐     │
│    │ 3.1 意图解析                              │     │
│    │     ESIntentParser.parse()               │     │
│    │     → 标准识别、实体提取、查询重写         │     │
│    │     → 流式输出思考过程                    │     │
│    └──────────────────────────────────────────┘     │
│    ┌──────────────────────────────────────────┐     │
│    │ 3.2 知识检索                              │     │
│    │     ESRetriever.retrieve(intent)         │     │
│    │     → BM25 + 向量混合检索                 │     │
│    │     → 返回List[Knowledge]                │     │
│    └──────────────────────────────────────────┘     │
│    ┌──────────────────────────────────────────┐     │
│    │ 3.3 构建提示词                            │     │
│    │     PromptBuilder.build()                │     │
│    │     → 拼接历史+知识+query                 │     │
│    └──────────────────────────────────────────┘     │
└──────┬──────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 4. 基础设施层（infrastructure/clients/）             │
│    ┌──────────────────────────────────────────┐     │
│    │ 4.1 调用LLM                               │     │
│    │     LLMClient.stream_chat(prompt)        │     │
│    │     → 流式生成回答                        │     │
│    └──────────────────────────────────────────┘     │
│    ┌──────────────────────────────────────────┐     │
│    │ 4.2 知识匹配                              │     │
│    │     KnowledgeMatcher.match()             │     │
│    │     → 匹配LLM输出与检索结果               │     │
│    └──────────────────────────────────────────┘     │
└──────┬──────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 5. 流式响应（application/streaming_service.py）      │
│    → 格式化标签（<think><data><knowledge>）           │
│    → 逐块返回前端（SSE）                              │
└──────┬──────────────────────────────────────────────┘
       ↓
┌──────────────────────────────────────────────────────┐
│ 6. 异步存储（infrastructure/repositories/）          │
│    MessageRepository.save()                          │
│    → 同时写入Redis和ES                               │
└──────────────────────────────────────────────────────┘
```

### 6.2 混合查询流程（Hybrid模式）

```
用户查询
  ↓
意图路由 → Decision: "hybrid"
  ↓
┌────────────────────────┐
│ Phase 1: Neo4j查询     │
│  - Neo4j意图解析        │
│  - 图数据库查询         │
│  - 提取业务信息         │
└──────────┬─────────────┘
           ↓
      业务信息结果
           ↓
┌────────────────────────┐
│ Phase 2: 增强查询       │
│  原始查询 + 业务信息     │
└──────────┬─────────────┘
           ↓
┌────────────────────────┐
│ Phase 3: ES查询         │
│  - ES意图解析           │
│  - 法规知识检索         │
│  - 知识匹配             │
└──────────┬─────────────┘
           ↓
┌────────────────────────┐
│ Phase 4: 合并生成       │
│  - 合并两类知识         │
│  - 统一Prompt构建       │
│  - LLM流式生成          │
└────────────────────────┘
```

---

## 7. 配置管理方案

### 7.1 配置分层策略

使用Pydantic Settings实现：

```python
# config/settings.py
from pydantic_settings import BaseSettings, SettingsConfigDict

class RedisSettings(BaseSettings):
    host: str = "localhost"
    port: int = 6379
    db: int = 0
    password: Optional[str] = None

    model_config = SettingsConfigDict(
        env_prefix="REDIS_",  # 环境变量前缀
        env_file=".env"
    )

class ESSettings(BaseSettings):
    host: str = "localhost"
    port: int = 9200
    username: str = "elastic"
    password: str
    knowledge_index: str = "kb_vector_store"
    conversation_index: str = "conversation_history"

    model_config = SettingsConfigDict(env_prefix="ES_")

class LLMSettings(BaseSettings):
    base_url: str
    api_key: str
    model_name: str = "deepseek-v3"
    max_tokens: int = 4000
    temperature: float = 0.7

    model_config = SettingsConfigDict(env_prefix="LLM_")

class Settings(BaseSettings):
    # 环境配置
    env: str = "development"  # development/production
    debug: bool = False

    # 服务配置
    redis: RedisSettings = RedisSettings()
    elasticsearch: ESSettings = ESSettings()
    mysql: MySQLSettings = MySQLSettings()
    neo4j: Neo4jSettings = Neo4jSettings()
    llm: LLMSettings = LLMSettings()
    embedding: EmbeddingSettings = EmbeddingSettings()

    # 业务配置
    max_history_length: int = 20
    session_timeout_minutes: int = 300

    model_config = SettingsConfigDict(env_file=".env")

# 全局配置实例
settings = Settings()
```

### 7.2 环境变量文件

**.env.example**：
```bash
# 环境配置
ENV=development
DEBUG=false

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=

# Elasticsearch配置
ES_HOST=localhost
ES_PORT=9200
ES_USERNAME=elastic
ES_PASSWORD=your_password_here
ES_KNOWLEDGE_INDEX=kb_vector_store
ES_CONVERSATION_INDEX=conversation_history

# MySQL配置
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=chatuser
MYSQL_PASSWORD=your_password_here
MYSQL_DATABASE=chatdb

# Neo4j配置
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_password_here

# LLM配置
LLM_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
LLM_API_KEY=your_api_key_here
LLM_MODEL_NAME=deepseek-v3
LLM_MAX_TOKENS=4000
LLM_TEMPERATURE=0.7

# Embedding服务配置
EMBEDDING_HOST=localhost
EMBEDDING_PORT=8000
EMBEDDING_URL=http://localhost:8000/embed

# 业务配置
MAX_HISTORY_LENGTH=20
SESSION_TIMEOUT_MINUTES=300
```

### 7.3 配置加载流程

```python
# main.py
from config.settings import settings

# 启动时验证配置
@app.on_event("startup")
async def validate_config():
    logger.info(f"Environment: {settings.env}")
    logger.info(f"Redis: {settings.redis.host}:{settings.redis.port}")
    # ... 其他配置验证
```

---

## 8. 日志与监控方案

### 8.1 统一日志规范

#### 日志配置（config/logging_config.py）：

```python
from loguru import logger
import sys

def setup_logging(env: str = "development"):
    """配置日志系统"""

    # 移除默认handler
    logger.remove()

    # 控制台输出（开发环境）
    if env == "development":
        logger.add(
            sys.stdout,
            level="DEBUG",
            format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
            colorize=True
        )

    # 文件输出（所有环境）
    logger.add(
        "logs/app_{time:YYYY-MM-DD}.log",
        rotation="500 MB",
        retention="7 days",
        compression="zip",
        level="INFO",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message}",
        enqueue=True  # 异步写入
    )

    # 错误日志单独文件
    logger.add(
        "logs/error_{time:YYYY-MM-DD}.log",
        rotation="500 MB",
        retention="30 days",
        level="ERROR",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} | {message} | {extra}",
        enqueue=True
    )

    # JSON格式日志（用于日志分析）
    logger.add(
        "logs/app_{time:YYYY-MM-DD}.json",
        rotation="500 MB",
        retention="7 days",
        level="INFO",
        serialize=True,  # JSON格式
        enqueue=True
    )

    return logger
```

#### 使用方式：

```python
from core.logging import logger

# 普通日志
logger.info("Processing query", extra={"user_id": user_id, "session_id": session_id})

# 错误日志（自动记录堆栈）
try:
    result = await some_operation()
except Exception as e:
    logger.exception(f"Operation failed: {e}", extra={"context": "important_context"})
```

### 8.2 请求日志中间件

```python
# core/middleware.py
import time
from fastapi import Request
from core.logging import logger

async def log_request_middleware(request: Request, call_next):
    """记录所有请求"""
    start_time = time.time()

    # 记录请求
    logger.info(
        f"Request started",
        extra={
            "method": request.method,
            "path": request.url.path,
            "client_ip": request.client.host
        }
    )

    # 执行请求
    response = await call_next(request)

    # 记录响应
    duration = time.time() - start_time
    logger.info(
        f"Request completed",
        extra={
            "method": request.method,
            "path": request.url.path,
            "status_code": response.status_code,
            "duration_ms": round(duration * 1000, 2)
        }
    )

    return response
```

### 8.3 监控指标

#### Prometheus指标（使用prometheus-fastapi-instrumentator）：

```python
from prometheus_fastapi_instrumentator import Instrumentator

# main.py
instrumentator = Instrumentator()
instrumentator.instrument(app).expose(app)

# 自定义指标
from prometheus_client import Counter, Histogram

# 请求计数
request_count = Counter(
    'chat_requests_total',
    'Total chat requests',
    ['scene_id', 'user_id']
)

# 响应时长
response_time = Histogram(
    'chat_response_seconds',
    'Chat response time',
    ['scene_id']
)

# LLM调用监控
llm_call_count = Counter(
    'llm_calls_total',
    'Total LLM API calls',
    ['model', 'status']
)
```

#### 健康检查端点：

```python
# api/v1/health.py
@router.get("/health")
async def health_check():
    """健康检查"""
    status = {
        "status": "ok",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }

    # 检查各服务状态
    try:
        await redis_client.ping()
        status["services"]["redis"] = "up"
    except:
        status["services"]["redis"] = "down"
        status["status"] = "degraded"

    # ... 检查其他服务

    return status
```

### 8.4 Langfuse集成（LLM追踪）

```python
# infrastructure/clients/llm_client.py
from langfuse import Langfuse

class LLMClient:
    def __init__(self):
        self.langfuse = Langfuse(
            public_key=settings.langfuse_public_key,
            secret_key=settings.langfuse_secret_key
        )

    async def stream_chat(self, prompt: str, **kwargs):
        # 创建trace
        trace = self.langfuse.trace(
            name="chat_completion",
            metadata={"user_id": kwargs.get("user_id")}
        )

        # 创建generation
        generation = trace.generation(
            name="llm_call",
            model=self.model_name,
            input=prompt,
            metadata=kwargs
        )

        # 调用LLM
        async for chunk in self._stream_call(prompt, **kwargs):
            yield chunk

        # 记录完整输出
        generation.end(output=full_output)
```

---

## 9. 部署架构

### 9.1 服务拓扑

```
                    ┌─────────────┐
                    │   Nginx     │  (反向代理、负载均衡)
                    └──────┬──────┘
                           │
              ┌────────────┴────────────┐
              ↓                         ↓
       ┌──────────────┐          ┌──────────────┐
       │  FastAPI实例1 │          │  FastAPI实例2 │  (多实例部署)
       └──────┬───────┘          └──────┬───────┘
              │                         │
              └────────────┬────────────┘
                           ↓
        ┌──────────────────────────────────────┐
        │        基础设施服务集群                │
        │  ┌────────┐  ┌────────┐  ┌────────┐ │
        │  │ Redis  │  │ MySQL  │  │   ES   │ │
        │  └────────┘  └────────┘  └────────┘ │
        │  ┌────────┐  ┌────────┐             │
        │  │ Neo4j  │  │Embedding│            │
        │  └────────┘  └────────┘             │
        └──────────────────────────────────────┘
```

### 9.2 容器化部署（Docker Compose）

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8011:8011"
    environment:
      - ENV=production
    env_file:
      - .env
    depends_on:
      - redis
      - mysql
      - elasticsearch
      - neo4j
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    deploy:
      replicas: 2  # 多实例

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
    volumes:
      - mysql_data:/var/lib/mysql

  # ... 其他服务

volumes:
  redis_data:
  mysql_data:
  es_data:
  neo4j_data:
```

---

## 10. 实施计划

### 10.1 分阶段重构策略

采用**绞杀者模式**（Strangler Fig Pattern），逐步替换旧代码：

#### 第一阶段：基础设施搭建（1-2周）
- [x] 建立新目录结构
- [x] 配置管理模块（config/）
- [x] 统一日志系统（core/logging.py）
- [x] 异常处理体系（core/exceptions.py）
- [x] 基础设施层客户端（infrastructure/clients/）
- [x] 编写单元测试框架

**验收标准**：
- 所有配置通过环境变量加载
- 日志输出符合规范
- 各客户端可独立测试

#### 第二阶段：领域层重构（2-3周）
- [x] 统一意图解析器（domain/services/intent_parser/）
- [x] 统一知识检索器（domain/services/retrieval/）
- [x] 提示词构建服务（domain/services/prompt_builder.py）
- [x] 知识匹配服务（domain/services/knowledge_matcher.py）

**验收标准**：
- 意图解析器通过单元测试
- 检索器可独立运行和测试
- 与旧代码输出结果一致

#### 第三阶段：应用层与API层（2周）
- [x] 应用服务层（application/）
- [x] API路由重构（api/v1/）
- [x] 流式响应服务（application/streaming_service.py）
- [x] 会话管理服务（application/session_service.py）

**验收标准**：
- 新API与旧API功能一致
- 端到端测试通过
- 性能不低于旧版本

#### 第四阶段：数据迁移与切换（1周）
- [x] 数据库schema迁移脚本
- [x] 历史数据迁移（如需要）
- [x] 灰度发布（新旧系统并行）
- [x] 流量切换

**验收标准**：
- 数据一致性验证
- 零停机切换
- 回滚预案验证

#### 第五阶段：监控与优化（持续）
- [x] Prometheus + Grafana仪表盘
- [x] Langfuse集成
- [x] 性能优化
- [x] 压力测试

**验收标准**：
- 关键指标可观测
- 告警机制生效
- 性能满足SLA

### 10.2 风险控制

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| 重构期间功能回归 | 高 | 完善的单元测试和集成测试 |
| 性能下降 | 中 | 每阶段性能对比测试 |
| 数据迁移失败 | 高 | 先在测试环境验证、准备回滚脚本 |
| 团队适应新架构 | 中 | 文档培训、代码审查 |
| 第三方服务不稳定 | 中 | 实现重试、降级、熔断机制 |

---

## 11. 关键设计决策

### 11.1 为什么选择分层架构？
- **清晰的职责边界**：每层只关注自己的职责
- **易于测试**：各层可独立测试
- **可替换性**：替换某一层不影响其他层
- **团队协作**：不同层可由不同团队维护

### 11.2 为什么使用Repository模式？
- **解耦数据访问**：业务逻辑不依赖具体数据库
- **统一接口**：Redis、ES、MySQL通过统一接口访问
- **缓存策略封装**：Redis优先、ES备用逻辑封装在Repository内

### 11.3 为什么使用依赖注入？
- **可测试性**：方便Mock依赖
- **松耦合**：服务间通过接口依赖
- **生命周期管理**：FastAPI Depends自动管理资源

### 11.4 为什么使用Pydantic Settings？
- **类型安全**：配置项有明确类型
- **验证**：启动时自动验证配置
- **IDE支持**：自动补全、类型检查
- **环境变量映射**：自动从环境变量加载



## 附录A：关键接口定义

### A.1 意图解析器接口

```python
from abc import ABC, abstractmethod
from typing import List
from domain.models.intent import Intent
from domain.models.message import Message

class BaseIntentParser(ABC):
    """意图解析器基类"""

    @abstractmethod
    async def parse(
        self,
        query: str,
        history: List[Message],
        stream_callback: Optional[Callable[[str], Awaitable[None]]] = None
    ) -> Intent:
        """
        解析用户意图

        Args:
            query: 用户查询
            history: 历史消息
            stream_callback: 流式输出回调

        Returns:
            Intent: 解析后的意图对象
        """
        pass
```

### A.2 检索器接口

```python
class BaseRetriever(ABC):
    """知识检索器基类"""

    @abstractmethod
    async def retrieve(self, intent: Intent) -> List[Knowledge]:
        """
        根据意图检索知识

        Args:
            intent: 解析后的意图

        Returns:
            List[Knowledge]: 检索到的知识列表
        """
        pass
```

### A.3 仓储接口

```python
class BaseRepository(ABC):
    """仓储基类"""

    @abstractmethod
    async def get(self, id: str) -> Optional[T]:
        """获取单条记录"""
        pass

    @abstractmethod
    async def create(self, entity: T) -> str:
        """创建记录"""
        pass

    @abstractmethod
    async def update(self, id: str, entity: T) -> bool:
        """更新记录"""
        pass

    @abstractmethod
    async def delete(self, id: str) -> bool:
        """删除记录"""
        pass
```

---

## 附录B：数据模型定义

### B.1 意图模型

```python
from pydantic import BaseModel
from typing import List, Optional

class Intent(BaseModel):
    """意图模型"""
    query: str  # 原始查询
    rewritten_query: str  # 重写后的查询
    intent_type: str  # 意图类型：es/neo4j/hybrid/none
    entities: List[str]  # 提取的实体
    standards: List[str]  # 识别的标准
    requirement_items: List[str]  # 要求项
    retrieval_strategy: str  # 检索策略：keyword/semantic/hybrid
```

### B.2 知识模型

```python
class Knowledge(BaseModel):
    """知识模型"""
    clause_key: str  # 条款唯一标识
    content: str  # 内容
    source_standard: str  # 来源标准
    identifier: str  # 标准编号
    section_levels: Dict[str, str]  # 章节层级
    applicability_level: str  # 适用级别
    score: float  # 检索相似度
    retrieval_path: str  # 检索路径
```

### B.3 消息模型

```python
class Message(BaseModel):
    """消息模型"""
    role: str  # user/assistant
    content: str  # 消息内容
    timestamp: datetime  # 时间戳
    metadata: Optional[Dict] = None  # 元数据
```

---

## 文档变更记录

| 版本 | 日期 | 作者 | 变更说明 |
|-----|------|------|---------|
| 2.0 | 2025-12-18 | hyy| 初始版本，完整重构设计 |