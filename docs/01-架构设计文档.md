# 网络安全智能问答系统 - 架构设计文档

**文档版本**: v4.0 (完全独立架构)
**编写日期**: 2025-12-26
---

## 一、架构概述

### 1.1 架构原则

本系统采用**Clean Architecture（整洁架构）**设计模式，也称为DDD（领域驱动设计）架构，遵循以下核心原则：

**✅ 依赖倒置原则（DIP）**
- 高层模块不依赖低层模块，两者都依赖于抽象
- 所有依赖方向指向内层（Core层）
- 外部框架和工具可替换

**✅ 单一职责原则（SRP）**
- 每个模块只有一个变化的理由
- Domain层关注业务逻辑
- Infrastructure层关注技术实现
- Application层关注业务编排

**✅ 开闭原则（OCP）**
- 对扩展开放，对修改关闭
- 新增功能通过继承和组合实现
- 不修改已有代码

**✅ 接口隔离原则（ISP）**
- 客户端不应依赖它不需要的接口
- 最小接口设计

### 1.2 分层架构

系统采用**Clean Architecture五层架构**（4层运行时+1层工具层）：

```
┌───────────────────────────────────────────┐
│       Tools Layer (离线工具)              │  ← 数据导入、初始化脚本
│         - tools/data_import/              │
│         * es_offline_setup_baseline       │
│         * add_data_for_existing_esdb      │
│         * add_cypher_examples             │
└───────────────────────────────────────────┘
           ↓ (数据准备完成)
┌───────────────────────────────────────────┐
│         API Layer (FastAPI)               │  ← HTTP接口、路由、依赖注入
│         - api/routers/                    │
│         - api/dependencies/               │
├───────────────────────────────────────────┤
│     Application Layer (Services)          │  ← 业务编排、流程控制
│         - application/services/           │
│         - LegacyStreamingService          │
│         - ChatService                     │
│         - SessionService                  │
├───────────────────────────────────────────┤
│      Domain Layer (Core Logic)            │  ← 领域服务、策略、实体
│         - domain/services/                │
│           * Neo4jQueryService (630行)     │
│           * ESQueryService (620行)        │
│         - domain/strategies/              │
│           * LLMIntentRouter               │
│         - domain/models/                  │
│         - domain/parsers/                 │
│         - domain/retrievers/              │
├───────────────────────────────────────────┤
│  Infrastructure Layer (Clients)           │  ← 外部服务客户端封装
│         - infrastructure/clients/         │
│           * LLMClient (with retry)        │
│           * ESClient (with retry)         │
│           * Neo4jClient (with retry)      │
│           * RedisClient                   │
│           * MySQLClient                   │
│         - infrastructure/repositories/    │
├───────────────────────────────────────────┤
│      Core Layer (Config/Utils)            │  ← 配置、日志、异常、重试、缓存
│         - core/config/                    │
│         - core/logging.py                 │
│         - core/exceptions.py              │
│         - core/retry.py (新增)            │
│         - core/cache.py (新增)            │
└───────────────────────────────────────────┘
           ↑
       Tests Layer (测试)
       - tests/ (~118个测试用例)
```

**运行时依赖方向**：API → Application → Domain → Infrastructure → Core

**工具层**: 独立于4层架构，专门用于离线数据准备

### 1.3 技术栈总览

| 层级 | 技术栈 | 说明 |
|------|--------|------|
| API层 | FastAPI, Pydantic, Uvicorn | 异步Web框架、数据验证、ASGI服务器 |
| Application层 | Asyncio, BackgroundTasks | 异步编排、后台任务 |
| Domain层 | Pure Python, Type Hints | 纯业务逻辑，无外部依赖 |
| Infrastructure层 | Elasticsearch-py, Neo4j-driver, Redis-py, PyMySQL | 各类客户端库 |
| Core层 | Pydantic-settings, Loguru | 配置管理、日志框架 |

---

## 二、各层详细设计

### 2.1 API Layer（API层）

**职责**：
- HTTP请求接收和响应
- 路由定义和参数验证
- 依赖注入容器
- 全局异常处理
- CORS配置

#### 2.1.1 目录结构

```
api/
├── dependencies/
│   └── app_dependencies.py      # 依赖注入容器（单例管理）
├── routers/
│   ├── chat_router.py           # 对话接口路由
│   └── session_router.py        # 会话管理路由
└── main.py                      # FastAPI应用入口
```

#### 2.1.2 依赖注入设计

**文件**: [api/dependencies/app_dependencies.py](../api/dependencies/app_dependencies.py)

**设计模式**: 单例模式 + 工厂模式

**核心函数**:

```python
# 客户端单例
def get_llm_client() -> LLMClient
def get_es_client() -> ESClient
def get_neo4j_client() -> Neo4jClient
def get_redis_client() -> RedisClient
def get_mysql_client() -> MySQLClient

# 仓储单例
async def get_session_repository() -> SessionRepository
async def get_message_repository() -> MessageRepository

# 领域服务单例
def get_neo4j_query_service() -> Neo4jQueryService
def get_es_query_service() -> ESQueryService

# 应用服务单例
async def get_legacy_streaming_service() -> LegacyStreamingService
async def get_chat_service() -> ChatService
async def get_session_service() -> SessionService
```

**依赖注入流程**:

```python
# 示例：LegacyStreamingService的依赖链
LegacyStreamingService
    ↓ 依赖
    ├─ LLMClient (单例)
    ├─ Neo4jQueryService (单例)
    │   ↓ 依赖
    │   ├─ LLMClient
    │   ├─ Neo4jClient (单例)
    │   └─ ESClient (单例)
    ├─ ESQueryService (单例)
    │   ↓ 依赖
    │   ├─ LLMClient
    │   └─ ESClient
    ├─ MessageRepository (单例)
    │   ↓ 依赖
    │   ├─ RedisClient (单例)
    │   └─ ESClient
    └─ SessionRepository (单例)
        ↓ 依赖
        ├─ RedisClient
        ├─ MySQLClient (单例)
        └─ ESClient
```

#### 2.1.3 路由设计

**主要接口**:

| 路由 | 方法 | 说明 | 实现文件 |
|------|------|------|----------|
| `/api/v1/chat/stream` | POST | 流式问答（主接口） | [chat_router.py](../api/routers/chat_router.py) |
| `/api/v1/sessions` | POST | 创建会话 | [session_router.py](../api/routers/session_router.py) |
| `/api/v1/sessions/{id}` | GET | 获取会话详情 | [session_router.py](../api/routers/session_router.py) |
| `/api/v1/sessions/{id}/messages` | GET | 获取会话历史 | [session_router.py](../api/routers/session_router.py) |
| `/api/v1/sessions/{id}` | DELETE | 删除会话 | [session_router.py](../api/routers/session_router.py) |

**流式输出（SSE）**:

```python
# chat_router.py
@router.post("/stream")
async def chat_stream(
    request: ChatStreamRequest,
    streaming_service: LegacyStreamingService = Depends(get_legacy_streaming_service),
    background_tasks: BackgroundTasks = BackgroundTasks()
):
    return StreamingResponse(
        streaming_service.chat_stream_by_scene(
            user_id=request.user_id,
            session_id=request.session_id,
            query=request.query,
            scene_id=request.scene_id,
            background_tasks=background_tasks
        ),
        media_type="text/event-stream"
    )
```

---

### 2.2 Application Layer（应用层）

**职责**：
- 业务流程编排
- 跨领域服务协调
- 会话管理
- 消息持久化
- 后台任务调度

#### 2.2.1 目录结构

```
application/
└── services/
    ├── legacy_streaming_service.py  # 流式服务（主要）
    ├── chat_service.py              # 对话服务（未使用）
    └── session_service.py           # 会话服务
```

#### 2.2.2 LegacyStreamingService设计

**文件**: [application/services/legacy_streaming_service.py](../application/services/legacy_streaming_service.py)

**职责**:
- 根据scene_id编排不同查询流程
- 调用Domain层服务（Neo4jQueryService、ESQueryService）
- 流式输出协调（SSE格式）
- 消息持久化（后台任务）

**三种场景流程**:

**场景1: 混合查询 (scene_id=1)**

```python
async def _hybrid_stream_gen():
    # 1. 智能路由判断
    routing_decision = await self.intent_router.route(question, history_msgs)
    yield SSE(路由思考过程, message_type=1)

    # 2. Neo4j业务查询
    neo4j_data_content = ""
    async for chunk in self._neo4j_stream_gen(...):
        yield chunk  # 流式输出
        # 收集<data>部分到neo4j_data_content

    # 3. 问题增强
    enhanced_question = question + "以下是检索到的具体业务信息：" + neo4j_data_content

    # 4. ES法规查询
    async for chunk in self._es_stream_gen(enhanced_question, ...):
        yield chunk  # 流式输出
```

**场景2: 纯业务查询 (scene_id=2)**

```python
async def _neo4j_stream_gen():
    # 直接调用Neo4jQueryService
    async for chunk in self.neo4j_service.query_stream(question, history_msgs):
        yield chunk
```

**场景3: 纯法规查询 (scene_id=3)**

```python
async def _es_stream_gen():
    # 直接调用ESQueryService
    async for chunk in self.es_service.query_stream(question, history_msgs):
        yield chunk
```

**构造器依赖**:

```python
def __init__(
    self,
    llm_client: LLMClient,
    neo4j_query_service: Neo4jQueryService,  # ✅ 依赖注入
    es_query_service: ESQueryService,        # ✅ 依赖注入
    message_repository: MessageRepository,
    session_repository: SessionRepository,
):
    self.llm_client = llm_client
    self.neo4j_service = neo4j_query_service
    self.es_service = es_query_service
    self.message_repo = message_repository
    self.session_repo = session_repository
    self.intent_router = LLMIntentRouter(llm_client)
```

---

### 2.3 Domain Layer（领域层）

**职责**：
- 核心业务逻辑
- 领域服务实现
- 策略模式实现
- 领域模型定义
- **完全独立，无外部依赖**

#### 2.3.1 目录结构

```
domain/
├── services/
│   ├── neo4j_query_service.py   # Neo4j查询服务
│   ├── es_query_service.py      # ES查询服务
│   ├── prompt_builder.py        # Prompt构建服务
│   ├── knowledge_matcher.py     # 知识匹配服务
│   └── memory_service.py        # 记忆服务
├── strategies/
│   └── llm_intent_router.py     # LLM路由策略
├── models/
│   ├── message.py               # 消息模型
│   ├── session.py               # 会话模型
│   ├── knowledge.py             # 知识模型
│   └── intent.py                # 意图模型
├── parsers/
│   ├── es_intent_parser.py      # ES意图解析器
│   └── neo4j_intent_parser.py   # Neo4j意图解析器
└── retrievers/
    ├── es_retriever.py          # ES检索器
    ├── neo4j_retriever.py       # Neo4j检索器
    └── hybrid_retriever.py      # 混合检索器
```

#### 2.3.2 Neo4jQueryService设计

**文件**: [domain/services/neo4j_query_service.py](../domain/services/neo4j_query_service.py)

**代码量**: 630行（完全独立实现）

**核心类**:

```python
class JsonExtractor:
    """JSON提取器 - 从LLM输出中提取JSON"""
    def extract(self, text: str) -> Optional[List]: ...

class Neo4jIntentParser:
    """Neo4j意图解析器配置"""
    def __init__(self):
        self.nodes = {...}  # 图数据库节点schema
        self.relationships = {...}  # 关系schema

class Neo4jQueryService:
    """Neo4j查询服务 - 完整独立实现"""

    def __init__(
        self,
        llm_client: LLMClient,
        neo4j_client: Neo4jClient,
        es_client: ESClient  # 用于Cypher示例检索
    ): ...

    async def query_stream(
        self,
        question: str,
        history_msgs: List[Dict[str, str]]
    ) -> AsyncGenerator[bytes, None]:
        """6阶段Neo4j查询流程"""
        ...
```

**6阶段查询流程**:

```python
async def query_stream(...):
    # Phase 1: 意图识别（流式输出）
    intent_result = await self._parse_intent_only_with_stream(
        question, history_msgs, stream_callback
    )

    # Phase 2: ES示例匹配
    for intent in intent_result:
        examples = await self._match_examples_from_es(intent)
        intent_with_examples.append((intent, examples))

    # Phase 3: 批量Cypher生成（流式输出）
    intent_with_cypher = await self._generate_cyphers_batch_with_stream(
        intent_with_examples, question, stream_callback
    )

    # Phase 4: 查询执行
    cypher_results = []
    for intent, cypher in intent_with_cypher:
        result = self.neo4j_client.query(cypher)
        cypher_results.append(result)

    # Phase 5: 摘要生成（流式输出）
    messages = [
        {"role": "system", "content": "你是业务专员..."},
        {"role": "user", "content": f"查询结果：{cypher_results}"},
        {"role": "user", "content": f"问题：{question}"}
    ]
    async for chunk in self.llm_client.stream_chat(messages):
        yield SSE(chunk, message_type=2)

    # Phase 6: 知识输出
    knowledge_data = {...}
    yield SSE(json.dumps(knowledge_data), message_type=3)
```

**关键方法**:

| 方法 | 说明 | 行数 |
|------|------|------|
| `query_stream()` | 主流程（6阶段） | ~220行 |
| `_parse_intent_only_with_stream()` | Phase 1: 意图识别 | ~70行 |
| `_match_examples_from_es()` | Phase 2: 示例匹配 | ~50行 |
| `_generate_cyphers_batch_with_stream()` | Phase 3: Cypher生成 | ~140行 |

#### 2.3.3 ESQueryService设计

**文件**: [domain/services/es_query_service.py](../domain/services/es_query_service.py)

**核心类**:

```python
@dataclass
class ESIntent:
    """ES意图数据模型"""
    num: int
    rewritten_query: str
    retrieval_type: str
    regulation_standards: List[str]
    source_standard: List[str]
    entities: Dict[str, List[str]]
    reason: str

@dataclass
class KnowledgeItem:
    """知识检索结果项"""
    content: str
    score: float
    source: str
    metadata: Dict[str, Any]

class ESQueryService:
    """ES查询服务 - 完整独立实现"""

    def __init__(self, llm_client: LLMClient, es_client: ESClient): ...

    async def query_stream(
        self,
        question: str,
        history_msgs: List[Dict[str, str]]
    ) -> AsyncGenerator[bytes, None]:
        """4阶段ES查询流程"""
        ...
```

**4阶段查询流程**:

```python
async def query_stream(...):
    # Phase 1: 意图解析（流式输出）
    intent_result = await self._parse_intent_with_stream(
        question, history_msgs, stream_callback
    )

    # Phase 2: 知识检索（BM25 + 向量）
    knowledge_results = await self._search_knowledge(intent_result)

    # Phase 3: 答案生成（流式输出）
    messages = [
        {"role": "system", "content": "你是网络安全等级保护专家..."},
        {"role": "user", "content": f"问题：{question}\n知识：{knowledge_text}"}
    ]
    async for chunk in self.llm_client.stream_chat(messages):
        yield SSE(chunk, message_type=2)

    # Phase 4: 知识匹配（Top 2）
    matched_knowledge = await self._match_knowledge(llm_output, knowledge_results)
    knowledge_dict = {"title": "相关的标准规范原文内容", "table_list": matched_knowledge}
    yield SSE(json.dumps(knowledge_dict), message_type=3)
```

**检索配置**:

```python
self.retrieval_config = {
    "keyword_search": {      # 关键词搜索
        "bm25_weight": 0.8,
        "vector_weight": 0.2,
        "bm25_threshold": 0.7,
        "vector_threshold": 0.3
    },
    "semantic_search": {     # 语义搜索
        "bm25_weight": 0.2,
        "vector_weight": 0.8,
        "bm25_threshold": 0.7,
        "vector_threshold": 0.3
    },
    "hybrid_search": {       # 混合搜索（默认）
        "bm25_weight": 0.6,
        "vector_weight": 0.4,
        "bm25_threshold": 0.7,
        "vector_threshold": 0.3
    }
}
```

#### 2.3.4 LLMIntentRouter设计

**文件**: [domain/strategies/llm_intent_router.py](../domain/strategies/llm_intent_router.py)

**职责**: 智能路由判断（neo4j / es / hybrid / none）

**核心实现**:

```python
class RouteDecision(BaseModel):
    """路由决策模型"""
    decision: Literal["neo4j", "es", "hybrid", "none"]
    reasoning: str
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)

class LLMIntentRouter:
    """LLM智能路由器"""

    async def route(
        self,
        question: str,
        history_msgs: List[Dict[str, str]]
    ) -> str:
        """
        路由决策

        Returns:
            "neo4j" | "es" | "hybrid" | "none"
        """
        # 调用LLM进行路由判断
        messages = [
            {"role": "system", "content": llm_router_prompt},
            {"role": "user", "content": f"用户问题：{question}"}
        ]

        response = await self.llm_client.async_chat(messages)

        # 解析JSON决策
        decision_dict = self._parse_decision(response)
        return decision_dict["decision"]
```

**路由提示词**（[core/config/prompts.py](../core/config/prompts.py)）:

```python
llm_router_prompt = """你是一个智能意图路由器...

知识库数据源说明：
1. neo4j：包含具体的业务数据，为业务图谱库
2. es：包含网络安全相关的法规、标准、规范、条款等权威文档
3. hybrid：需要同时使用业务数据和法规标准进行对比分析
4. none：不需要检索任何知识库

请按照以下JSON格式输出你的决策：
{
  "decision": "neo4j/es/hybrid/none",
  "reasoning": "详细的决策理由",
  "confidence": 0.9
}
"""
```

---

### 2.4 Infrastructure Layer（基础设施层）

**职责**：
- 封装外部服务客户端
- 数据持久化
- 缓存管理
- 第三方API调用

#### 2.4.1 目录结构

```
infrastructure/
├── clients/
│   ├── llm_client.py        # LLM客户端（OpenAI兼容）
│   ├── es_client.py         # Elasticsearch客户端
│   ├── neo4j_client.py      # Neo4j图数据库客户端
│   ├── redis_client.py      # Redis缓存客户端
│   └── mysql_client.py      # MySQL数据库客户端
└── repositories/
    ├── session_repository.py    # 会话仓储（三层存储）
    └── message_repository.py    # 消息仓储（双层存储）
```

#### 2.4.2 LLMClient设计

**文件**: [infrastructure/clients/llm_client.py](../infrastructure/clients/llm_client.py)

**职责**: 封装OpenAI兼容接口的LLM调用

**核心方法**:

```python
class LLMClient:
    """大语言模型客户端"""

    def __init__(self, settings: LLMSettings):
        self.base_url = settings.base_url
        self.api_key = settings.api_key
        self.chat_model = settings.chat_generation_model
        self.client = openai.AsyncOpenAI(
            base_url=self.base_url,
            api_key=self.api_key
        )

    async def async_chat(
        self,
        messages: List[Dict[str, str]],
        model: Optional[str] = None,
        **kwargs
    ) -> str:
        """异步非流式对话"""
        ...

    async def stream_chat(
        self,
        messages: List[Dict[str, str]],
        model: Optional[str] = None,
        **kwargs
    ) -> AsyncGenerator[str, None]:
        """异步流式对话"""
        async for chunk in self.client.chat.completions.create(
            model=model or self.chat_model,
            messages=messages,
            stream=True,
            **kwargs
        ):
            if chunk.choices[0].delta.content:
                yield chunk.choices[0].delta.content

    def sync_stream_chat(
        self,
        messages: List[Dict[str, str]],
        **kwargs
    ) -> Generator[str, None, None]:
        """同步流式对话（用于非异步上下文）"""
        ...
```

#### 2.4.3 ESClient设计

**文件**: [infrastructure/clients/es_client.py](../infrastructure/clients/es_client.py)

**职责**: 封装Elasticsearch操作

```python
class ESClient:
    """Elasticsearch客户端"""

    def __init__(self, settings: ESSettings):
        self.client = Elasticsearch(
            [{"host": settings.host, "port": settings.port, "scheme": "http"}],
            basic_auth=(settings.username, settings.password),
            verify_certs=False
        )

    def search(
        self,
        index: str,
        query: Dict,
        size: int = 10,
        **kwargs
    ) -> Dict:
        """ES查询"""
        return self.client.search(index=index, query=query, size=size, **kwargs)

    def index(
        self,
        index: str,
        document: Dict,
        doc_id: Optional[str] = None
    ) -> Dict:
        """索引文档"""
        ...
```

#### 2.4.4 Neo4jClient设计

**文件**: [infrastructure/clients/neo4j_client.py](../infrastructure/clients/neo4j_client.py)

**职责**: 封装Neo4j图数据库操作

```python
class Neo4jClient:
    """Neo4j图数据库客户端"""

    def __init__(self, settings: Neo4jSettings):
        self.driver = GraphDatabase.driver(
            settings.uri,
            auth=(settings.user, settings.password)
        )
        self.database = settings.database

    def query(
        self,
        cypher: str,
        parameters: Optional[Dict] = None
    ) -> List[Dict]:
        """执行Cypher查询"""
        with self.driver.session(database=self.database) as session:
            result = session.run(cypher, parameters or {})
            return [record.data() for record in result]

    def close(self):
        """关闭连接"""
        self.driver.close()
```

#### 2.4.5 SessionRepository设计

**文件**: [infrastructure/repositories/session_repository.py](../infrastructure/repositories/session_repository.py)

**存储策略**: 三层存储（Redis → MySQL → ES）

```python
class SessionRepository:
    """会话仓储 - 三层存储"""

    def __init__(
        self,
        redis_client: RedisClient,
        mysql_client: MySQLClient,
        es_client: ESClient
    ):
        self.redis_client = redis_client
        self.mysql_client = mysql_client
        self.es_client = es_client

    async def create_session(self, session: Session) -> Session:
        """
        创建会话

        存储顺序：
        1. Redis缓存（快速访问）
        2. MySQL持久化（数据安全）
        3. ES索引（全文检索）
        """
        # 1. Redis缓存
        await self.redis_client.set(
            f"session:{session.id}",
            session.to_dict(),
            ttl=86400
        )

        # 2. MySQL持久化
        self.mysql_client.insert("sessions", session.to_dict())

        # 3. ES索引
        self.es_client.index(
            index="conversation_history",
            document=session.to_dict(),
            doc_id=session.id
        )

        return session

    async def get_session(self, session_id: str) -> Optional[Session]:
        """
        获取会话

        查询顺序：
        1. Redis缓存（最快）
        2. MySQL数据库（次快）
        3. ES索引（最慢）
        """
        # 1. 尝试从Redis获取
        session_data = await self.redis_client.get(f"session:{session_id}")
        if session_data:
            return Session.from_dict(session_data)

        # 2. 从MySQL获取
        session_data = self.mysql_client.query_one(
            "SELECT * FROM sessions WHERE id = %s", (session_id,)
        )
        if session_data:
            # 回写Redis
            await self.redis_client.set(f"session:{session_id}", session_data, ttl=86400)
            return Session.from_dict(session_data)

        return None
```

---

### 2.5 Core Layer（核心层）

**职责**：
- 配置管理
- 日志框架
- 异常定义
- 通用工具

#### 2.5.1 目录结构

```
core/
├── config/
│   ├── settings.py      # 配置类（Pydantic）
│   └── prompts.py       # 系统提示词配置
├── logging.py           # 日志配置（Loguru）
├── exceptions.py        # 自定义异常
└── utils.py             # 通用工具函数
```

#### 2.5.2 配置管理设计

**文件**: [core/config/settings.py](../core/config/settings.py)

**设计模式**: Pydantic Settings

```python
class LLMSettings(BaseModel):
    """LLM配置"""
    base_url: str = Field(default="https://dashscope.aliyuncs.com/compatible-mode/v1")
    api_key: str = Field(default="")
    chat_generation_model: str = Field(default="deepseek-v3")
    intent_router_model: str = Field(default="deepseek-v3")
    chat_generation_max_tokens: int = Field(default=4096)
    chat_generation_temperature: float = Field(default=0.7)

class ESSettings(BaseModel):
    """Elasticsearch配置"""
    host: str = Field(default="localhost")
    port: int = Field(default=9200)
    username: str = Field(default="elastic")
    password: str = Field(default="password01")
    knowledge_index: str = Field(default="kb_vector_store")
    conversation_index: str = Field(default="conversation_history")
    cypher_index: str = Field(default="qa_system")

class Neo4jSettings(BaseModel):
    """Neo4j配置"""
    uri: str = Field(default="bolt://localhost:7687")
    user: str = Field(default="neo4j")
    password: str = Field(default="password")
    database: str = Field(default="neo4j")

class Settings(BaseSettings):
    """总配置类"""
    llm: LLMSettings = Field(default_factory=LLMSettings)
    es: ESSettings = Field(default_factory=ESSettings)
    neo4j: Neo4jSettings = Field(default_factory=Neo4jSettings)
    redis: RedisSettings = Field(default_factory=RedisSettings)
    mysql: MySQLSettings = Field(default_factory=MySQLSettings)

    class Config:
        env_file = ".env"
        env_nested_delimiter = "__"  # 支持 LLM__BASE_URL 格式

@lru_cache()
def get_settings() -> Settings:
    """获取配置单例"""
    return Settings()
```

#### 2.5.3 日志管理设计

**文件**: [core/logging.py](../core/logging.py)

**日志框架**: Loguru

```python
from loguru import logger

# 配置日志格式
logger.remove()  # 移除默认handler
logger.add(
    sys.stdout,
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
    level="INFO"
)

# 文件日志
logger.add(
    "logs/app_{time:YYYY-MM-DD}.log",
    rotation="00:00",  # 每天午夜轮换
    retention="30 days",  # 保留30天
    compression="zip",
    level="DEBUG"
)

# 使用示例
logger.info("系统启动")
logger.debug(f"配置加载成功: {settings}")
logger.error(f"查询失败: {error}", exc_info=True)
```

---

### 2.6 Tools Layer（离线工具层）

**职责**：
- 离线数据导入和初始化
- 数据库维护脚本
- 独立于运行时服务

#### 2.6.1 目录结构

```
tools/
├── __init__.py
└── data_import/                          # 数据导入工具
    ├── __init__.py
    ├── es_offline_setup_baseline.py      # ES基础数据导入
    ├── add_data_for_existing_esdb.py     # ES增量数据导入
    ├── create_newesdb_conversation_history.py  # 对话历史索引
    ├── add_cypher_examples.py            # Cypher示例导入
    └── mysql_offline_setup_baseline.py   # MySQL初始化
```

#### 2.6.2 与4层架构的关系

**关键区别**：

| 特性 | 4层架构 | Tools层 |
|------|---------|---------|
| 运行时机 | 在线运行 | 离线运行 |
| 依赖关系 | 分层依赖 | 独立脚本 |
| 数据流向 | 用户请求→响应 | CSV→数据库 |
| 配置管理 | core/config | 硬编码配置 |
| 使用频率 | 持续运行 | 初始化/维护时 |

**数据流时序**：

```
阶段1：数据准备（离线）
  knowledge/knowledgedata/*.csv
    ↓
  tools/data_import/es_offline_setup_baseline.py
    ↓
  Elasticsearch索引就绪（kb_vector_store）

阶段2：运行时查询（在线）
  用户问题 → API Layer → Application Layer → Domain Layer
    ↓
  Infrastructure Layer（ESClient检索kb_vector_store）
    ↓
  返回答案
```

#### 2.6.3 工具说明

| 工具文件 | 功能 | 输入 | 输出 |
|---------|------|------|------|
| es_offline_setup_baseline.py | ES基础数据导入 | CSV文件 | kb_vector_store索引 |
| add_data_for_existing_esdb.py | ES增量数据导入 | CSV文件 | 更新kb_vector_store |
| create_newesdb_conversation_history.py | 对话历史索引 | - | conversation_history索引 |
| add_cypher_examples.py | Cypher示例导入 | Python列表 | qa_system索引 |
| mysql_offline_setup_baseline.py | MySQL初始化 | - | 数据库表 |

#### 2.6.4 使用流程

**首次部署**：

```bash
cd tools/data_import

# 1. MySQL初始化
python mysql_offline_setup_baseline.py

# 2. ES基础数据导入（测评要求.csv + 基本要求.csv）
python es_offline_setup_baseline.py

# 3. Cypher示例导入
python add_cypher_examples.py
```

**增量更新**（添加新法规）：

```bash
python add_data_for_existing_esdb.py
```

---

## 三、核心设计模式

### 3.1 依赖注入模式

**实现方式**: 构造器注入 + 单例模式

**优点**:
- ✅ 松耦合：服务之间通过接口依赖
- ✅ 易测试：可轻松mock依赖
- ✅ 易扩展：新增服务无需修改现有代码

**示例**:

```python
# ❌ 错误：硬编码依赖
class BadService:
    def __init__(self):
        self.llm_client = LLMClient(get_settings().llm)  # 硬编码
        self.es_client = ESClient(get_settings().es)      # 硬编码

# ✅ 正确：依赖注入
class GoodService:
    def __init__(self, llm_client: LLMClient, es_client: ESClient):
        self.llm_client = llm_client  # 注入
        self.es_client = es_client    # 注入
```

### 3.2 策略模式

**应用场景**: LLMIntentRouter路由策略

**实现**:

```python
class IntentRoutingStrategy(ABC):
    """路由策略接口"""
    @abstractmethod
    async def route(self, question: str, history: List[Dict]) -> str:
        pass

class LLMIntentRouter(IntentRoutingStrategy):
    """LLM路由策略实现"""
    async def route(self, question: str, history: List[Dict]) -> str:
        # LLM判断路由
        ...

# 未来可扩展
class RuleBasedRouter(IntentRoutingStrategy):
    """基于规则的路由策略"""
    async def route(self, question: str, history: List[Dict]) -> str:
        # 关键词匹配路由
        ...
```

### 3.3 仓储模式

**应用场景**: 数据持久化抽象

**实现**:

```python
class SessionRepository:
    """会话仓储"""
    async def create_session(self, session: Session) -> Session: ...
    async def get_session(self, session_id: str) -> Optional[Session]: ...
    async def update_session(self, session: Session) -> Session: ...
    async def delete_session(self, session_id: str) -> bool: ...

# 具体实现可以切换存储方式（Redis/MySQL/ES）
# 对业务层透明
```

### 3.4 工厂模式

**应用场景**: 依赖注入容器

**实现**:

```python
# 工厂函数
def get_neo4j_query_service() -> Neo4jQueryService:
    """工厂：创建Neo4jQueryService单例"""
    global _neo4j_query_service
    if _neo4j_query_service is None:
        llm_client = get_llm_client()      # 依赖工厂
        neo4j_client = get_neo4j_client()  # 依赖工厂
        es_client = get_es_client()        # 依赖工厂
        _neo4j_query_service = Neo4jQueryService(llm_client, neo4j_client, es_client)
    return _neo4j_query_service
```

### 3.5 生成器模式

**应用场景**: 流式输出

**实现**:

```python
async def query_stream(...) -> AsyncGenerator[bytes, None]:
    """异步生成器：流式输出SSE数据"""
    for chunk in llm_response:
        yield f"data:{json.dumps(chunk)}\n\n".encode("utf-8")
```

---

## 四、数据流设计

### 4.1 混合查询数据流

```
用户请求
    ↓
FastAPI Router (chat_router.py)
    ↓
LegacyStreamingService.chat_stream_by_scene()
    ↓
【阶段1: 路由判断】
LLMIntentRouter.route() → "hybrid"
    ↓
【阶段2: Neo4j查询】
Neo4jQueryService.query_stream()
    ├─ Phase 1: LLM意图识别 → intent_result
    ├─ Phase 2: ES示例匹配 → examples
    ├─ Phase 3: Cypher生成 → cypher_list
    ├─ Phase 4: Neo4j执行 → cypher_results
    ├─ Phase 5: LLM摘要生成 → neo4j_answer
    └─ Phase 6: 知识输出 → neo4j_knowledge
    ↓ (收集<data>部分)
neo4j_data_content = "A单位部署了XXX防火墙..."
    ↓
【阶段3: 问题增强】
enhanced_question = question + "以下是检索到的具体业务信息：" + neo4j_data_content
    ↓
【阶段4: ES查询】
ESQueryService.query_stream(enhanced_question)
    ├─ Phase 1: LLM意图解析 → es_intent_result
    ├─ Phase 2: ES混合检索 → knowledge_results
    ├─ Phase 3: LLM答案生成 → es_answer
    └─ Phase 4: 知识匹配 → es_knowledge (Top 2)
    ↓
【阶段5: 流式输出】
SSE流 → 用户前端
```

### 4.2 消息持久化流程

```
用户发送消息
    ↓
LegacyStreamingService接收
    ↓
BackgroundTasks.add_task(message_repo.append_message)
    ↓
MessageRepository.append_message()
    ├─ Redis缓存: list key = "messages:{user_id}:{session_id}"
    └─ ES索引: index = "conversation_history"
```

### 4.3 会话创建流程

```
用户创建会话
    ↓
SessionService.create_session()
    ↓
SessionRepository.create_session()
    ├─ 1. Redis缓存: key = "session:{session_id}", ttl = 86400
    ├─ 2. MySQL持久化: table = "sessions"
    └─ 3. ES索引: index = "conversation_history"
```

---

## 五、性能优化设计

### 5.1 异步I/O

**设计要点**:
- ✅ 所有I/O操作使用async/await
- ✅ LLM调用使用异步客户端（openai.AsyncOpenAI）
- ✅ 数据库查询使用异步驱动
- ✅ SSE流式输出使用异步生成器

**示例**:

```python
# ✅ 异步LLM调用
async def query_stream(...):
    async for chunk in self.llm_client.stream_chat(messages):
        yield chunk

# ✅ 并发调用（Phase 2示例匹配）
async def match_examples(intents):
    tasks = [self._match_single_intent(intent) for intent in intents]
    results = await asyncio.gather(*tasks)
    return results
```

### 5.2 缓存策略

**三层缓存**:

| 层级 | 存储 | TTL | 用途 |
|------|------|-----|------|
| L1 | 内存（单例） | 进程生命周期 | 配置、客户端实例 |
| L2 | Redis | 24小时 | 会话、消息历史 |
| L3 | MySQL/ES | 永久 | 持久化存储 |

**缓存读取顺序**: L1 → L2 → L3

**缓存写入顺序**: L3 → L2 → L1

### 5.3 流式输出优化

**设计要点**:
- ✅ 使用asyncio.Queue解耦生产者和消费者
- ✅ 使用asyncio.Event同步任务完成
- ✅ chunk粒度控制（避免过大或过小）

**示例**:

```python
# 生产者-消费者模式
async def producer(queue: asyncio.Queue):
    async for chunk in llm_stream:
        await queue.put(chunk)
    await queue.put(None)  # 结束标记

async def consumer(queue: asyncio.Queue):
    while True:
        chunk = await queue.get()
        if chunk is None:
            break
        yield chunk
```

---

## 六、安全性设计

### 6.1 输入验证

**Pydantic数据验证**:

```python
class ChatStreamRequest(BaseModel):
    user_id: str = Field(..., min_length=1, max_length=100)
    session_id: str = Field(..., min_length=1, max_length=100)
    query: str = Field(..., min_length=1, max_length=5000)
    scene_id: int = Field(..., ge=1, le=3)
```

### 6.2 Cypher注入防护

**参数化查询**:

```python
# ❌ 危险：字符串拼接
cypher = f"MATCH (n) WHERE n.name = '{user_input}' RETURN n"

# ✅ 安全：参数化
cypher = "MATCH (n) WHERE n.name = $name RETURN n"
parameters = {"name": user_input}
result = neo4j_client.query(cypher, parameters)
```

### 6.3 敏感信息保护

**配置加密**:
- API Key通过环境变量传入
- 密码不硬编码在代码中
- 日志中过滤敏感信息

```python
logger.debug(f"LLM调用: model={model}, prompt={prompt[:50]}...")  # 只记录前50字符
```

---

## 七、可扩展性设计

### 7.1 新增查询场景

**步骤**:
1. 在Domain层实现新的QueryService
2. 在Application层的LegacyStreamingService添加新场景分支
3. 在API层的chat_router添加新的scene_id

**示例**:

```python
# 1. Domain层
class HybridPlusQueryService:
    """混合增强查询服务"""
    async def query_stream(...): ...

# 2. Application层
class LegacyStreamingService:
    async def chat_stream_by_scene(...):
        if scene_id == 4:  # 新场景
            async for chunk in self._hybrid_plus_stream_gen(...):
                yield chunk

# 3. API层（无需修改，自动支持）
```

### 7.2 新增知识源

**步骤**:
1. 在Infrastructure层实现新的Client
2. 在Domain层实现新的Retriever
3. 在依赖注入容器注册新服务

**示例**:

```python
# 1. Infrastructure层
class PGVectorClient:
    """PostgreSQL向量数据库客户端"""
    ...

# 2. Domain层
class PGVectorRetriever:
    """PGVector检索器"""
    def __init__(self, pgvector_client: PGVectorClient): ...
    async def retrieve(...): ...

# 3. 依赖注入
def get_pgvector_retriever() -> PGVectorRetriever:
    client = get_pgvector_client()
    return PGVectorRetriever(client)
```

### 7.3 新增路由策略

**步骤**:
1. 实现IntentRoutingStrategy接口
2. 在依赖注入容器注册
3. 在Application层切换策略

**示例**:

```python
# 1. 实现接口
class MLClassifierRouter(IntentRoutingStrategy):
    """基于机器学习分类器的路由"""
    async def route(...):
        prediction = self.ml_model.predict(question)
        return prediction

# 2. 注入容器
def get_ml_router() -> MLClassifierRouter:
    return MLClassifierRouter()

# 3. 切换策略
class LegacyStreamingService:
    def __init__(self, ..., router: IntentRoutingStrategy):
        self.intent_router = router  # 可切换
```

---

## 八、测试策略

### 8.1 单元测试

**测试框架**: pytest

**Mock策略**:

```python
# 测试Neo4jQueryService
@pytest.mark.asyncio
async def test_neo4j_query_service():
    # Mock依赖
    mock_llm_client = MagicMock(spec=LLMClient)
    mock_neo4j_client = MagicMock(spec=Neo4jClient)
    mock_es_client = MagicMock(spec=ESClient)

    # 注入Mock
    service = Neo4jQueryService(mock_llm_client, mock_neo4j_client, mock_es_client)

    # 测试
    result = await service.query_stream("测试问题", [])
    assert result is not None
```

### 8.2 集成测试

**测试范围**: API → Application → Domain → Infrastructure

```python
# 测试完整流程
@pytest.mark.asyncio
async def test_chat_stream_e2e():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.post("/api/v1/chat/stream", json={
            "user_id": "test_user",
            "session_id": "test_session",
            "query": "等保三级对防火墙有什么要求？",
            "scene_id": 3
        })
        assert response.status_code == 200
```

---

## 九、部署架构

### 9.1 容器化部署

**Docker Compose**:

```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - LLM_BASE_URL=${LLM_BASE_URL}
      - ES_HOST=elasticsearch
      - NEO4J_URI=bolt://neo4j:7687
      - REDIS_HOST=redis
      - MYSQL_HOST=mysql
    depends_on:
      - elasticsearch
      - neo4j
      - redis
      - mysql

  elasticsearch:
    image: elasticsearch:8.11.0
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node

  neo4j:
    image: neo4j:4.4
    ports:
      - "7474:7474"
      - "7687:7687"

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  mysql:
    image: mysql:8
    ports:
      - "3306:3306"
```

### 9.2 高可用部署

```
┌─────────────┐
│   Nginx     │  ← 负载均衡
│  (80/443)   │
└──────┬──────┘
       │
   ┌───┴────┐
   │        │
┌──▼──┐  ┌──▼──┐
│ App1│  │ App2│  ← 多实例部署
│:8000│  │:8001│
└──┬──┘  └──┬──┘
   │        │
   └────┬───┘
        │
   ┌────▼─────┐
   │  Redis   │  ← 缓存集群
   │ Cluster  │
   └────┬─────┘
        │
   ┌────▼─────┐
   │   ES     │  ← ES集群
   │ Cluster  │
   └────┬─────┘
        │
   ┌────▼─────┐
   │  Neo4j   │  ← Neo4j集群（可选）
   │ Cluster  │
   └──────────┘
```

---

## 十、总结

### 10.1 架构优势

1. **完全独立**：0个old代码导入，100%重写核心服务
2. **架构清晰**：Clean Architecture四层架构，依赖方向明确
3. **松耦合**：依赖注入+接口设计，易于测试和扩展
4. **高性能**：异步I/O+流式输出+三层缓存
5. **易维护**：模块化设计，单一职责，文档完整

### 10.2 关键指标

| 指标 | 数值 |
|------|------|
| 代码行数 | Neo4jQueryService 630行<br/>ESQueryService 620行<br/>总计 ~5000行 |
| old依赖 | 0个 |
| 测试覆盖率 | 待完善 |
| 性能 | TTFB < 2s<br/>完整生成 < 30s |
| 可用性 | > 99% |

### 10.3 未来优化方向

1. **性能优化**
   - 向量检索性能提升
   - Cypher查询优化
   - 缓存策略优化

2. **功能扩展**
   - 支持更多LLM模型
   - 支持更多知识源
   - 支持多租户

3. **质量提升**
   - 单元测试覆盖
   - 集成测试自动化
   - 性能压测

---

**文档结束**

本架构设计文档详细描述了系统的分层架构、核心模块设计、设计模式应用、数据流、性能优化、安全性、可扩展性等方面，为系统开发、维护和扩展提供全面的技术指导。
