# COMBINE_LLM 数据库设计文档

## 版本：2.0
## 更新日期：2025-12-18
## 文档性质：数据库设计

---

## 📌 文档说明

本文档详细说明COMBINE_LLM系统使用的所有数据库设计，包括：
- **Elasticsearch**：向量检索、全文检索、会话历史
- **Neo4j**：知识图谱、业务关系
- **MySQL**：用户和会话元数据
- **Redis**：会话缓存、短期记忆
---

## 目录

1. [数据库总览](#1-数据库总览)
2. [Elasticsearch设计](#2-elasticsearch设计)
3. [Neo4j设计](#3-neo4j设计)
4. [MySQL设计](#4-mysql设计)
5. [Redis设计](#5-redis设计)
6. [数据流转与同步](#6-数据流转与同步)
7. [性能优化建议](#7-性能优化建议)

---

## 1. 数据库总览

### 1.1 数据库角色分工

本系统采用多数据库架构，每个数据库承担特定职责：

| 数据库 | 角色 | 存储内容 | 访问模式 | 数据量 |
|-------|------|---------|---------|--------|
| **Elasticsearch** | 核心检索引擎 | 法规知识库、会话历史、用户记忆 | 混合检索（BM25+向量） | 百万级 |
| **Neo4j** | 知识图谱 | 业务实体、关系网络 | Cypher图查询 | 十万级节点 |
| **MySQL** | 元数据持久化 | 用户信息、会话元数据 | 关系查询、事务 | 万级 |
| **Redis** | 高速缓存 | 活跃会话消息、会话列表 | KV访问、List/Hash | 实时数据 |

**设计理念**：
- **Elasticsearch**：作为检索引擎，存储所有需要搜索的数据（法规条文、历史对话）
- **Neo4j**：专门处理复杂关系查询，如"河北分公司的所有网络系统由哪些集成商建设"
- **MySQL**：作为唯一的事实来源（Single Source of Truth），存储用户和会话的元数据
- **Redis**：作为第一层缓存，提供极速访问，过期后从ES恢复

### 1.2 数据一致性策略

#### 数据流向

**创建会话时的数据流向**：
1. 首先写入MySQL（持久化，作为事实来源）
2. 同步写入Redis（快速访问）
3. 异步写入Elasticsearch（检索和分析）

**流式对话时的数据流向**：
1. 读取历史消息：优先从Redis读取，未命中时从ES读取并回填Redis
2. 保存新消息：同时写入Redis（实时）和ES（持久化）

**数据恢复流程**：
- Redis失效或过期时，自动从ES读取历史数据
- 读取后回填Redis，设置过期时间为24小时
- 用户无感知，系统自动降级服务

#### 一致性级别

| 场景 | 一致性级别 | 说明 |
|-----|-----------|------|
| **创建会话** | 强一致性 | MySQL写入成功后才写Redis和ES |
| **保存消息** | 最终一致性 | Redis和ES并行写入，允许短暂不一致 |
| **删除会话** | 强一致性 | MySQL删除成功后删除Redis和ES |
| **Redis失效** | 自动恢复 | 从ES读取并回填Redis |

---

## 2. Elasticsearch设计

### 2.1 服务信息

| 配置项 | 值 |
|-------|---|
| **地址** | localhost:9200 |
| **版本** | 8.x+ |
| **认证方式** | Basic Auth |
| **用户名** | elastic |
| **密码** | password01 |
| **Kibana地址** | localhost:5601 |

### 2.2 索引设计

Elasticsearch共有3个索引，分别负责不同的数据存储和检索任务。

---

#### 2.2.1 kb_vector_store（法规知识向量库）

##### 索引用途

存储所有法规条文的原始内容、元数据及其向量表示，是回答问题的主要知识来源。

##### 数据来源

- 来源文件1：knowledgedata/测评要求.csv
- 来源文件2：knowledgedata/基本要求.csv
- 来源文件3：knowledgedata/等保测评管理办法.csv
- 来源文件4：knowledgedata/等保管理办法.csv

这些CSV文件通过数据导入脚本解析后，生成结构化文档并写入ES。

##### 字段设计

本索引包含以下字段：

**1. 序号字段**
- 字段名称：序号
- 数据类型：keyword（关键字类型，不分词）
- 用途：记录序号，用于唯一标识每条记录
- 是否索引：是

**2. 内容字段（核心检索字段）**
- 字段名称：内容（Content）
- 数据类型：text（文本类型，支持分词）
- 分词器：ik_max_word（索引时使用，细粒度分词）
- 搜索分词器：ik_smart（搜索时使用，粗粒度分词）
- 用途：存储法规条款的完整内容，支持全文检索
- 是否索引：是

**3. 标准出处字段**
- 字段名称：标准出处(source_standard)
- 数据类型：keyword
- 用途：标准名称，如"信息安全技术网络安全等级保护基本要求"
- 是否索引：是
- 用于过滤：按标准名称过滤查询结果

**4. 标识字段**
- 字段名称：标识(identifier)
- 数据类型：keyword
- 用途：标准编号，如"GB/T 22239-2019"
- 是否索引：是
- 用于过滤：按标准编号过滤查询结果

**5. 对应要求项字段**
- 字段名称：对应要求项（requirement_item）
- 数据类型：keyword
- 用途：要求项名称，如"物理访问控制"、"网络架构"等
- 是否索引：是
- 用于过滤：按要求项过滤查询结果

**6. 章节层级字段（五级标题）**
- 字段名称：一级标题（section_level1）、二级标题（section_level2）、三级标题（section_level3）、四级标题（section_level4）、五级标题（section_level5）
- 数据类型：全部为keyword
- 用途：表示法规条文的章节层级结构，便于按章节过滤
- 是否索引：是
- 示例：一级标题="物理和环境安全"，二级标题="物理访问控制"

**7. 适用级别字段**
- 字段名称：适用级别（applicability_level）
- 数据类型：keyword
- 用途：标识该条款适用的等保级别，如"第三级"、"第二级"
- 是否索引：是
- 用于过滤：按等保级别过滤查询结果

**8. 条款唯一标识符字段**
- 字段名称：clause_key_en
- 数据类型：keyword
- 用途：条款的全局唯一标识符，用于精确定位和去重
- 是否索引：是
- doc_values：启用，支持排序和聚合

**9. 要求项英文标识字段**
- 字段名称：requirement_item_en
- 数据类型：keyword
- 用途：要求项的英文标识符（内部使用）
- 是否索引：是

**10. 适用级别英文标识字段**
- 字段名称：applicability_level_en
- 数据类型：keyword
- 用途：适用级别的英文标识符（内部使用）
- 是否索引：是

**11. 内容向量字段（核心向量检索字段）**
- 字段名称：content_embedding
- 数据类型：dense_vector（稠密向量）
- 向量维度：1024维
- 向量模型：bge-large-zh（北京智源的中文向量模型）
- 相似度算法：cosine（余弦相似度）
- 是否索引：是（支持向量检索）
- 用途：存储内容的向量表示，用于语义相似度检索

**12. 向量化内容字段**
- 字段名称：embedding_content
- 数据类型：text
- 用途：用于展示的内容（可能包含格式化标记），与向量对应
- 是否索引：是

##### 索引配置

**分片配置**：
- 主分片数：1个（数据量百万级，单分片足够）
- 副本分片数：1个（提高查询性能和数据可靠性）

**分词器配置**：
- 分词插件：ik_analyzer（中文分词插件）
- 索引分词器：ik_max_word（细粒度分词，索引时使用）
- 搜索分词器：ik_smart（粗粒度分词，搜索时使用）

##### 检索策略

本索引支持多种检索模式：

**1. BM25全文检索**
- 基于字段：内容（Content）
- 算法：BM25（Best Matching 25，ES默认算法）
- 适用场景：关键词精确匹配，如搜索"物理访问控制"
- 返回结果：按BM25分数排序

**2. 向量语义检索**
- 基于字段：content_embedding
- 算法：KNN（K-Nearest Neighbors）+ 余弦相似度
- 适用场景：语义相似查询，如"如何防止未授权人员进入机房"
- 返回结果：按向量相似度排序

**3. 混合检索**
- 综合使用：BM25 + 向量检索
- 权重分配：可调整（默认各占50%）
- 适用场景：同时考虑关键词匹配和语义相似度
- 返回结果：综合分数排序

**4. 元数据过滤**
- 过滤字段：标识(identifier)、适用级别(applicability_level)、对应要求项(requirement_item)
- 使用方式：在检索前先过滤，缩小搜索范围
- 示例：仅搜索"第三级"的"物理访问控制"相关条款

##### 示例文档结构描述

一个典型的文档包含以下内容：

- 序号：1
- 内容：应建立物理访问控制策略，对进入机房的人员进行身份验证，并记录访问日志...（完整条文内容）
- 标准出处：信息安全技术网络安全等级保护基本要求
- 标识：GB/T 22239-2019
- 对应要求项：物理访问控制
- 一级标题：物理和环境安全
- 二级标题：物理访问控制
- 三级标题：（如有）
- 四级标题：（如有）
- 五级标题：（如有）
- 适用级别：第三级
- clause_key_en：ck_a1b2c3d4e5f6（系统生成的唯一标识）
- content_embedding：一个1024维的浮点数向量（如[0.123, -0.456, 0.789, ...]）
- embedding_content：【物理访问控制】应建立物理访问控制策略...（带格式化标记的内容）

---

#### 2.2.2 conversation_history（会话历史索引）

##### 索引用途

持久化存储会话历史记录，支持Redis缓存未命中时查询，以及历史分析。

##### 数据来源

- 来源：应用服务层的ChatService和MessageRepository
- 写入时机：每次用户发送消息和助手返回响应后，同步或异步写入

##### 字段设计

**1. 用户ID字段**
- 字段名称：user_id
- 数据类型：keyword
- 用途：标识消息所属的用户
- 是否索引：是
- 用于查询：按用户ID查询该用户的所有历史消息

**2. 会话ID字段**
- 字段名称：session_id
- 数据类型：keyword
- 用途：标识消息所属的会话（每个会话是一个独立对话）
- 是否索引：是
- 用于查询：按会话ID查询该会话的所有消息

**3. 消息ID字段**
- 字段名称：message_id
- 数据类型：keyword
- 用途：消息的唯一标识符
- 生成规则：msg_{session_id}_{timestamp}
- 是否索引：是
- 用于去重：防止重复写入同一条消息

**4. 角色字段**
- 字段名称：role
- 数据类型：keyword
- 可选值：user（用户）、assistant（助手）
- 用途：标识消息的发送者
- 是否索引：是
- 用于过滤：仅查询用户消息或助手消息

**5. 内容字段**
- 字段名称：content
- 数据类型：text
- 分词器：ik_max_word
- 用途：消息的文本内容
- 是否索引：是
- 用于搜索：全文检索历史对话内容

**6. 时间戳字段**
- 字段名称：timestamp
- 数据类型：date（日期类型）
- 格式：strict_date_time（ISO 8601格式，如"2025-12-18T10:00:00Z"）
- 用途：记录消息的发送时间
- 是否索引：是
- 用于排序和范围查询：按时间排序、查询某时间段的消息

**7. 消息顺序字段**
- 字段名称：message_order
- 数据类型：integer（整数）
- 用途：记录消息在会话中的顺序（从0开始）
- 是否索引：是
- 用于排序：确保消息按发送顺序排列

##### 索引配置

**分片配置**：
- 主分片数：1个
- 副本分片数：1个

**分词器配置**：
- 分词插件：ik_analyzer
- 分词器：ik_max_word（仅用于content字段）

##### 检索策略

**1. 按会话查询**
- 查询条件：session_id精确匹配（term query）
- 排序：按timestamp或message_order升序
- 返回结果：该会话的所有消息，按时间顺序排列

**2. 按用户查询**
- 查询条件：user_id精确匹配（term query）
- 排序：按timestamp降序（最新的在前）
- 返回结果：该用户的所有历史消息

**3. 时间范围查询**
- 查询条件：timestamp范围查询（range query）
- 示例：查询2025-12-01到2025-12-18之间的消息
- 排序：按timestamp升序或降序

**4. 全文检索历史对话**
- 查询字段：content
- 算法：BM25
- 示例：搜索所有包含"物理访问控制"的历史对话
- 返回结果：按相关性排序

##### 示例文档结构描述

一个典型的消息文档：

- user_id：user_001
- session_id：sess_abc123
- message_id：msg_sess_abc123_1734524800000
- role：user
- content：什么是物理访问控制？
- timestamp：2025-12-18T10:00:00Z
- message_order：0

下一条消息（助手回复）：

- user_id：user_001
- session_id：sess_abc123
- message_id：msg_sess_abc123_1734524805000
- role：assistant
- content：物理访问控制是指对进入机房等物理场所的人员进行身份验证和授权管理...
- timestamp：2025-12-18T10:00:05Z
- message_order：1

---

#### 2.2.3 user_memory（用户长期记忆库）

##### 索引用途

存储经过提炼的用户历史对话摘要，用于个性化服务和避免重复错误。

##### 数据来源

- 来源：MemoryService（记忆服务）
- 生成时机：会话结束后，LLM对对话进行总结提炼
- 写入频率：每个会话结束后异步写入

##### 字段设计

**1. 用户ID字段**
- 字段名称：user_id
- 数据类型：keyword
- 用途：标识记忆所属的用户
- 是否索引：是
- 用于过滤：仅查询该用户的记忆（隐私保护）

**2. 会话ID字段**
- 字段名称：session_id
- 数据类型：keyword
- 用途：标识该记忆来源于哪个会话
- 是否索引：是
- 用于追溯：查找记忆对应的原始对话

**3. 原始提问字段**
- 字段名称：query_text
- 数据类型：text
- 分词器：ik_max_word
- 用途：用户的原始提问
- 是否索引：是
- 用于关键词检索：查找相似历史问题

**4. 提问向量字段**
- 字段名称：query_embedding
- 数据类型：dense_vector
- 向量维度：1024维
- 相似度算法：cosine
- 用途：提问的向量表示，用于语义相似度检索
- 是否索引：是

**5. 会话摘要字段**
- 字段名称：summary_text
- 数据类型：text
- 用途：由LLM生成的会话摘要（提炼关键信息）
- 是否索引：是
- 示例：用户咨询了第三级等保的物理访问控制要求，重点关注人员身份验证和日志记录

**6. 助手回答字段**
- 字段名称：assistant_response
- 数据类型：text
- 用途：助手的回答内容
- 是否索引：是
- 用于参考：下次遇到相似问题时直接参考历史回答

**7. 满意度评分字段**
- 字段名称：satisfaction_score
- 数据类型：integer
- 取值范围：1-5（1=非常不满意，5=非常满意）
- 用途：用户对该次对话的满意度评分（可选）
- 是否索引：是
- 用于过滤：优先检索高分记忆

**8. 时间戳字段**
- 字段名称：timestamp
- 数据类型：date
- 用途：记录记忆的创建时间
- 是否索引：是
- 用于排序和衰减：越新的记忆权重越高

##### 索引配置

**分片配置**：
- 主分片数：1个
- 副本分片数：1个

##### 检索策略

**1. 向量语义检索**
- 基于字段：query_embedding
- 算法：KNN + 余弦相似度
- 适用场景：用户提出新问题时，查找相似的历史问题
- 过滤条件：仅查询该用户的记忆（user_id匹配）
- 返回结果：最相似的Top 3-5条记忆

**2. 时间衰减排序**
- 排序策略：相似度分数 × 时间衰减因子
- 时间衰减因子：越新的记忆权重越高
- 目的：平衡相似度和时效性

**3. 满意度过滤**
- 过滤条件：satisfaction_score >= 3
- 目的：仅参考用户满意的历史回答，避免重复错误

##### 示例文档结构描述

一个典型的记忆文档：

- user_id：user_001
- session_id：sess_abc123
- query_text：第三级等保的物理访问控制有哪些要求？
- query_embedding：一个1024维的向量
- summary_text：用户咨询了第三级等保的物理访问控制要求，关注点包括：1) 人员身份验证机制；2) 访问日志记录要求；3) 应急预案。助手详细解释了GB/T 22239-2019标准的相关条款。
- assistant_response：根据GB/T 22239-2019标准，第三级等保的物理访问控制要求包括：1. 应建立物理访问控制策略...（完整回答内容）
- satisfaction_score：5（用户非常满意）
- timestamp：2025-12-18T10:05:00Z

---

## 3. Neo4j设计

### 3.1 服务信息

| 配置项 | 值 |
|-------|---|
| **HTTP地址** | localhost:7474 |
| **Bolt地址** | localhost:7687 |
| **版本** | 5.x+ |
| **认证方式** | 用户名密码 |
| **用户名** | neo4j |
| **密码** | ChangeMe123! |
| **数据库名** | neo4j（默认数据库） |

### 3.2 图模型设计

Neo4j采用属性图模型（Property Graph Model），由节点（Node）和关系（Relationship）组成。

---

#### 3.2.1 节点类型（Node Labels）

本系统定义了5种节点类型，每种节点代表业务领域中的一个实体。

**1. Unit节点（单位）**

- **标签名称**：Unit
- **含义**：业务单位，如分公司、子公司
- **主要属性**：
  - id：单位唯一标识符（字符串类型，如"unit_001"）
  - name：单位名称（字符串类型，如"河北分公司"）
  - code：单位编码（字符串类型，如"HEBEI_001"）
  - location：单位所在地（字符串类型，如"河北省石家庄市"）
  - type：单位类型（字符串类型，如"分公司"、"子公司"）

**2. Network节点（网络）**

- **标签名称**：Network
- **含义**：网络系统，如核心网、接入网
- **主要属性**：
  - id：网络唯一标识符（字符串类型，如"network_001"）
  - name：网络名称（字符串类型，如"河北核心网"）
  - type：网络类型（字符串类型，如"核心网"、"接入网"）
  - level：等保级别（字符串类型，如"第三级"、"第二级"）
  - build_date：建设日期（日期类型，如"2023-01-01"）

**3. System节点（系统）**

- **标签名称**：System
- **含义**：业务系统，如CRM系统、ERP系统
- **主要属性**：
  - id：系统唯一标识符（字符串类型，如"system_001"）
  - name：系统名称（字符串类型，如"CRM系统"）
  - version：系统版本（字符串类型，如"v2.3"）
  - status：系统状态（字符串类型，如"运行中"、"维护中"）

**4. Device节点（设备）**

- **标签名称**：Device
- **含义**：网络设备，如服务器、交换机、防火墙
- **主要属性**：
  - id：设备唯一标识符（字符串类型，如"device_001"）
  - name：设备名称（字符串类型，如"核心交换机01"）
  - type：设备类型（字符串类型，如"服务器"、"交换机"、"防火墙"）
  - ip_address：IP地址（字符串类型，如"192.168.1.100"）

**5. Integrator节点（集成商）**

- **标签名称**：Integrator
- **含义**：系统集成商，负责系统建设和集成
- **主要属性**：
  - id：集成商唯一标识符（字符串类型，如"integrator_001"）
  - name：集成商名称（字符串类型，如"华为技术有限公司"）
  - qualification：资质等级（字符串类型，如"一级"、"二级"）

---

#### 3.2.2 关系类型（Relationship Types）

关系连接两个节点，表示它们之间的业务关联。每种关系有固定的起始节点和目标节点类型。

**1. BUILDS关系（建设）**

- **关系名称**：BUILDS
- **起始节点**：Unit（单位）
- **目标节点**：Network（网络）
- **含义**：单位建设了某个网络
- **关系属性**：
  - build_date：建设日期（日期类型）
  - budget：建设预算（数值类型，单位：万元）
- **查询场景**：查询某单位建设了哪些网络

**2. OPERATES关系（运营）**

- **关系名称**：OPERATES
- **起始节点**：Unit（单位）
- **目标节点**：Network（网络）
- **含义**：单位运营某个网络
- **关系属性**：
  - start_date：运营开始日期（日期类型）
- **查询场景**：查询某单位运营哪些网络

**3. CONTAINS关系（包含）**

- **关系名称**：CONTAINS
- **起始节点**：Network（网络）
- **目标节点**：System（系统）
- **含义**：网络包含某个业务系统
- **关系属性**：无
- **查询场景**：查询某网络包含哪些系统

**4. RUNS_ON关系（运行于）**

- **关系名称**：RUNS_ON
- **起始节点**：System（系统）
- **目标节点**：Device（设备）
- **含义**：系统运行在某个设备上
- **关系属性**：无
- **查询场景**：查询某系统运行在哪些设备上

**5. INTEGRATED_BY关系（集成）**

- **关系名称**：INTEGRATED_BY
- **起始节点**：System（系统）
- **目标节点**：Integrator（集成商）
- **含义**：系统由某集成商集成建设
- **关系属性**：
  - contract_date：合同签订日期（日期类型）
- **查询场景**：查询某系统由哪个集成商建设

---

#### 3.2.3 节点属性示例

**Unit节点示例**：
- 标签：Unit
- 属性值：
  - id = "unit_001"
  - name = "河北分公司"
  - code = "HEBEI_001"
  - location = "河北省石家庄市"
  - type = "分公司"

**Network节点示例**：
- 标签：Network
- 属性值：
  - id = "network_001"
  - name = "河北核心网"
  - type = "核心网"
  - level = "第三级"
  - build_date = "2023-01-01"

**System节点示例**：
- 标签：System
- 属性值：
  - id = "system_001"
  - name = "CRM系统"
  - version = "v2.3"
  - status = "运行中"

---

#### 3.2.4 常用Cypher查询模式

Neo4j使用Cypher查询语言（类似SQL），以下是常见查询场景的文字描述。

**查询场景1：查询单位建设的网络**

- 查询目的：找出"河北分公司"建设了哪些网络
- 查询逻辑：
  1. 匹配标签为Unit的节点，且name属性为"河北分公司"
  2. 沿着BUILDS关系，找到目标Network节点
  3. 返回单位节点和网络节点
- 返回结果：单位节点u和网络节点n的所有属性

**查询场景2：查询网络的集成商**

- 查询目的：找出"河北核心网"涉及的所有集成商
- 查询逻辑：
  1. 匹配标签为Network的节点，且name属性为"河北核心网"
  2. 沿着CONTAINS关系，找到所有System节点
  3. 再沿着INTEGRATED_BY关系，找到Integrator节点
  4. 去重后返回所有集成商节点
- 返回结果：去重后的集成商节点列表

**查询场景3：查询系统运行在哪些设备上**

- 查询目的：找出"CRM系统"运行在哪些设备上
- 查询逻辑：
  1. 匹配标签为System的节点，且name属性为"CRM系统"
  2. 沿着RUNS_ON关系，找到所有Device节点
  3. 返回系统节点和设备节点
- 返回结果：系统节点s和设备节点d的所有属性

**查询场景4：多跳查询（复杂关系）**

- 查询目的：找出"河北分公司"建设的所有网络中，所有系统的集成商
- 查询逻辑：
  1. 匹配单位"河北分公司"
  2. 沿着BUILDS关系找到所有网络
  3. 沿着CONTAINS关系找到所有系统
  4. 沿着INTEGRATED_BY关系找到所有集成商
  5. 去重后返回集成商列表
- 返回结果：所有集成商的名称和资质

---

### 3.3 索引设计

为了提高查询性能，需要为常查询的属性创建索引。

**推荐创建的索引**：

1. **Unit节点索引**：
   - 索引属性：name（单位名称）
   - 索引类型：B-tree索引
   - 用途：按单位名称快速查找

2. **Network节点索引**：
   - 索引属性：name（网络名称）
   - 索引类型：B-tree索引
   - 用途：按网络名称快速查找

3. **System节点索引**：
   - 索引属性：name（系统名称）
   - 索引类型：B-tree索引
   - 用途：按系统名称快速查找

4. **Device节点索引**：
   - 索引属性：ip_address（IP地址）
   - 索引类型：B-tree索引
   - 用途：按IP地址快速查找设备

---

## 4. MySQL设计

### 4.1 服务信息

| 配置项 | 值 |
|-------|---|
| **地址** | localhost:3306 |
| **版本** | 8.0+ |
| **数据库名** | chatdb |
| **用户名** | chatuser |
| **密码** | ChangeMe123! |
| **字符集** | utf8mb4 |
| **排序规则** | utf8mb4_unicode_ci |
| **存储引擎** | InnoDB |

### 4.2 表设计

MySQL作为唯一的事实来源（Single Source of Truth），存储用户和会话的元数据。

---

#### 4.2.1 users（用户表）

##### 表用途

存储用户基本信息，是系统的核心主表之一。

##### 字段设计

**1. user_id（主键）**
- 数据类型：VARCHAR(64)
- 约束：PRIMARY KEY（主键）
- 含义：用户ID，唯一标识符
- 生成规则：通常为UUID（如"user_abc123def456"）
- 是否允许NULL：否

**2. username**
- 数据类型：VARCHAR(100)
- 约束：NOT NULL（不允许为空）
- 含义：用户名
- 示例："张三"、"user001"
- 是否允许NULL：否

**3. email**
- 数据类型：VARCHAR(200)
- 约束：允许为空
- 含义：用户邮箱
- 示例："zhangsan@example.com"
- 是否允许NULL：是

**4. created_at**
- 数据类型：DATETIME
- 约束：NOT NULL，默认值为CURRENT_TIMESTAMP
- 含义：用户创建时间
- 是否允许NULL：否
- 自动填充：插入记录时自动填充当前时间

**5. updated_at**
- 数据类型：DATETIME
- 约束：NOT NULL，默认值为CURRENT_TIMESTAMP，ON UPDATE CURRENT_TIMESTAMP
- 含义：用户信息更新时间
- 是否允许NULL：否
- 自动更新：每次更新记录时自动更新为当前时间

**6. is_active**
- 数据类型：TINYINT(1)
- 约束：NOT NULL，默认值为1
- 含义：用户是否活跃
- 取值：1=活跃，0=停用
- 是否允许NULL：否

##### 索引设计

**1. 主键索引**：
- 索引名称：PRIMARY
- 索引字段：user_id
- 索引类型：B-tree（聚簇索引）
- 用途：唯一标识用户

**2. 普通索引1**：
- 索引名称：idx_username
- 索引字段：username
- 索引类型：B-tree
- 用途：按用户名查询

**3. 普通索引2**：
- 索引名称：idx_created_at
- 索引字段：created_at
- 索引类型：B-tree
- 用途：按创建时间排序和范围查询

##### 表配置

- 存储引擎：InnoDB（支持事务、外键）
- 字符集：utf8mb4（支持emoji和特殊字符）
- 表注释：用户表

---

#### 4.2.2 sessions（会话表）

##### 表用途

存储会话元数据，每个会话代表一次独立的对话。

##### 字段设计

**1. session_id（主键）**
- 数据类型：VARCHAR(64)
- 约束：PRIMARY KEY（主键）
- 含义：会话ID，唯一标识符
- 生成规则：UUID（如"sess_abc123def456"）
- 是否允许NULL：否

**2. user_id（外键）**
- 数据类型：VARCHAR(64)
- 约束：NOT NULL，FOREIGN KEY（外键，关联users表的user_id）
- 含义：会话所属的用户ID
- 是否允许NULL：否
- 外键约束：ON DELETE CASCADE（删除用户时级联删除其所有会话）

**3. name**
- 数据类型：VARCHAR(200)
- 约束：NOT NULL，默认值为'对话'
- 含义：会话名称
- 示例："法规咨询"、"第三级等保要求"
- 是否允许NULL：否

**4. created_at**
- 数据类型：DATETIME
- 约束：NOT NULL，默认值为CURRENT_TIMESTAMP
- 含义：会话创建时间
- 是否允许NULL：否
- 自动填充：插入记录时自动填充当前时间

**5. updated_at**
- 数据类型：DATETIME
- 约束：NOT NULL，默认值为CURRENT_TIMESTAMP，ON UPDATE CURRENT_TIMESTAMP
- 含义：会话最后更新时间（每次新消息时更新）
- 是否允许NULL：否
- 自动更新：每次更新记录时自动更新为当前时间

**6. is_active**
- 数据类型：TINYINT(1)
- 约束：NOT NULL，默认值为1
- 含义：会话是否活跃
- 取值：1=活跃，0=已删除
- 是否允许NULL：否

##### 索引设计

**1. 主键索引**：
- 索引名称：PRIMARY
- 索引字段：session_id
- 索引类型：B-tree（聚簇索引）
- 用途：唯一标识会话

**2. 外键索引**：
- 索引名称：idx_user_id
- 索引字段：user_id
- 索引类型：B-tree
- 用途：按用户ID查询其所有会话，支持外键约束

**3. 普通索引1**：
- 索引名称：idx_created_at
- 索引字段：created_at
- 索引类型：B-tree
- 用途：按创建时间排序

**4. 普通索引2**：
- 索引名称：idx_updated_at
- 索引字段：updated_at
- 索引类型：B-tree
- 用途：按更新时间排序（用于显示最近会话）

##### 约束设计

**外键约束**：
- 约束名称：FK_sessions_users
- 外键字段：user_id
- 参照表：users
- 参照字段：user_id
- 删除规则：ON DELETE CASCADE（删除用户时自动删除其所有会话）
- 更新规则：默认（RESTRICT）

##### 表配置

- 存储引擎：InnoDB（支持事务、外键）
- 字符集：utf8mb4
- 表注释：会话表

---

## 5. Redis设计

### 5.1 服务信息

| 配置项 | 值 |
|-------|---|
| **地址** | localhost:6379 |
| **版本** | 7.x+ |
| **数据库** | db 0（默认数据库） |
| **密码** | （可选，根据环境配置） |
| **持久化** | RDB + AOF混合模式 |

### 5.2 数据结构设计

Redis作为第一层缓存，提供极速访问。本系统使用两种数据结构：Hash和List。

---

#### 5.2.1 会话元数据（Hash结构）

##### Key格式

- Key命名规则：chat:{user_id}:sessions
- 示例：chat:user_001:sessions
- 含义：存储某用户的所有会话元数据

##### 数据结构

- 数据类型：Hash（哈希表）
- Hash的Field：session_id（会话ID）
- Hash的Value：JSON字符串（包含会话名称和创建时间）

##### Value的JSON结构

JSON字符串包含以下字段：
- name：会话名称（字符串）
- created_at：创建时间（ISO 8601格式字符串，如"2025-12-18T10:00:00Z"）

##### 示例数据

- Key：chat:user_001:sessions
- Field1：sess_abc123
- Value1：JSON字符串，内容为 name="法规咨询"，created_at="2025-12-18T10:00:00Z"
- Field2：sess_def456
- Value2：JSON字符串，内容为 name="等保测评"，created_at="2025-12-18T11:00:00Z"

##### 操作说明

**创建会话操作**：
- 操作类型：HSET
- 命令描述：向Hash中添加一个新的Field-Value对
- 参数：Key为chat:user_001:sessions，Field为sess_abc123，Value为JSON字符串

**获取所有会话操作**：
- 操作类型：HGETALL
- 命令描述：获取Hash中的所有Field-Value对
- 参数：Key为chat:user_001:sessions
- 返回结果：所有会话的ID和元数据

**删除会话操作**：
- 操作类型：HDEL
- 命令描述：删除Hash中的一个Field-Value对
- 参数：Key为chat:user_001:sessions，Field为sess_abc123

##### 过期策略

- 过期时间：永久（不设置过期时间）
- 原因：会话元数据需要与MySQL同步，不能过期
- 删除时机：仅当用户明确删除会话时，才从Redis中删除

---

#### 5.2.2 会话消息列表（List结构）

##### Key格式

- Key命名规则：chat:{user_id}:session:{session_id}:messages
- 示例：chat:user_001:session:sess_abc123:messages
- 含义：存储某会话的所有消息

##### 数据结构

- 数据类型：List（有序列表）
- 列表元素：JSON字符串（每个元素代表一条消息）
- 顺序：按时间顺序，最早的消息在索引0，最新的消息在末尾

##### 元素的JSON结构

JSON字符串包含以下字段：
- role：角色（字符串，取值为"user"或"assistant"）
- content：消息内容（字符串）
- ts：时间戳（ISO 8601格式字符串）

##### 示例数据

- Key：chat:user_001:session:sess_abc123:messages
- 列表元素：
  - 索引0：JSON字符串，内容为 role="user"，content="什么是物理访问控制？"，ts="2025-12-18T10:00:00Z"
  - 索引1：JSON字符串，内容为 role="assistant"，content="物理访问控制是指..."，ts="2025-12-18T10:00:05Z"
  - 索引2：JSON字符串，内容为 role="user"，content="有哪些要求？"，ts="2025-12-18T10:01:00Z"

##### 操作说明

**追加消息操作**：
- 操作类型：RPUSH
- 命令描述：在List的尾部追加一个新元素
- 参数：Key为chat:user_001:session:sess_abc123:messages，Value为JSON字符串
- 用途：保存新消息

**获取所有消息操作**：
- 操作类型：LRANGE
- 命令描述：获取List中指定范围的元素
- 参数：Key为chat:user_001:session:sess_abc123:messages，start为0，end为-1（-1表示最后一个元素）
- 返回结果：所有消息的JSON字符串列表

**获取最近N条消息操作**：
- 操作类型：LRANGE
- 命令描述：获取List末尾的N个元素
- 参数：Key为chat:user_001:session:sess_abc123:messages，start为-20，end为-1
- 返回结果：最近20条消息的JSON字符串列表
- 用途：构建LLM上下文时，仅需要最近几轮对话

**设置过期时间操作**：
- 操作类型：EXPIRE
- 命令描述：为Key设置过期时间
- 参数：Key为chat:user_001:session:sess_abc123:messages，过期时间为86400秒（24小时）
- 用途：活跃会话保持在内存，不活跃会话自动过期

**删除消息列表操作**：
- 操作类型：DEL
- 命令描述：删除整个Key
- 参数：Key为chat:user_001:session:sess_abc123:messages
- 用途：删除会话时同时删除消息列表

##### 过期策略

- 过期时间：24小时（86400秒）
- 原因：活跃会话保持在内存中，提高访问速度；不活跃会话自动过期，节省内存
- 过期后行为：从Elasticsearch读取历史消息，并回填Redis

---

#### 5.2.3 数据过期策略汇总

| Key类型 | 过期时间 | 说明 |
|--------|---------|------|
| **会话元数据Hash** | 永久 | 不设置过期，与MySQL同步 |
| **会话消息List** | 24小时 | 活跃会话保持在内存，过期后从ES加载 |

---

## 6. 数据流转与同步

本节描述数据在各数据库之间的流转和同步机制。

### 6.1 创建会话流程

**流程概述**：
当用户创建新会话时，数据依次写入MySQL、Redis、Elasticsearch。

**详细步骤**：

1. **API层接收请求**：
   - 用户通过HTTP POST请求创建会话
   - 请求体包含：user_id（用户ID）、name（会话名称）

2. **SessionService处理请求**：
   - 调用create_session方法
   - 生成session_id（UUID）
   - 生成created_at（当前UTC时间）

3. **写入MySQL（第一步，强一致性）**：
   - 向sessions表插入一条记录
   - 字段：session_id, user_id, name, created_at
   - 目的：持久化存储，作为唯一事实来源
   - 若写入失败：立即返回错误，不执行后续步骤

4. **写入Redis（第二步，同步）**：
   - 使用HSET命令
   - Key：chat:{user_id}:sessions
   - Field：session_id
   - Value：JSON字符串（包含name和created_at）
   - 目的：提供快速访问

5. **写入Elasticsearch（第三步，异步）**：
   - 作为后台任务异步执行
   - 索引：conversation_history
   - 文档ID：{user_id}_{session_id}
   - 文档内容：user_id, session_id, messages（初始为空数组）
   - 目的：支持检索和分析

6. **返回结果**：
   - 返回session_id给用户

**错误处理**：
- MySQL写入失败：立即返回错误，不执行后续步骤
- Redis写入失败：记录日志，不影响主流程（可降级）
- ES写入失败：记录日志，后续通过定时任务补偿

---

### 6.2 流式对话流程

**流程概述**：
用户发送消息后，系统读取历史消息、进行意图解析和知识检索、调用LLM生成回答、保存消息。

**详细步骤**：

**阶段1：读取历史消息**

1. **尝试从Redis读取**：
   - Key：chat:{user_id}:session:{session_id}:messages
   - 使用LRANGE命令获取所有消息（索引0到-1）
   - 若Redis中有数据：直接返回，跳到阶段2
   - 若Redis中无数据（未命中）：执行下一步

2. **从Elasticsearch读取（缓存未命中）**：
   - 索引：conversation_history
   - 查询条件：user_id匹配且session_id匹配
   - 排序：按timestamp升序
   - 返回结果：该会话的所有历史消息

3. **回填Redis（缓存预热）**：
   - 遍历从ES读取的消息
   - 使用RPUSH命令逐条追加到Redis List
   - 使用EXPIRE命令设置过期时间为86400秒（24小时）
   - 目的：下次访问时直接从Redis读取

**阶段2：意图解析 + 知识检索 + LLM生成**

4. **意图解析**：
   - 调用IntentParser解析用户查询
   - 确定查询类型（ES查询、Neo4j查询、混合查询）

5. **知识检索**：
   - 根据查询类型调用相应的Retriever
   - 从知识库检索相关知识

6. **提示词构建**：
   - 调用PromptBuilder构建提示词
   - 包含：历史消息、检索到的知识、用户记忆

7. **LLM生成**：
   - 调用LLMClient发送请求
   - 流式接收LLM响应
   - 通过SSE实时返回给用户

**阶段3：保存消息（并行）**

8. **保存用户消息到Redis**：
   - 使用RPUSH命令追加用户消息
   - JSON字符串包含：role="user", content, ts

9. **保存用户消息到Elasticsearch**：
   - 并行执行（与Redis写入同时进行）
   - 索引：conversation_history
   - 文档字段：user_id, session_id, message_id, role="user", content, timestamp, message_order

10. **保存助手消息到Redis**：
    - 使用RPUSH命令追加助手消息
    - JSON字符串包含：role="assistant", content, ts

11. **保存助手消息到Elasticsearch**：
    - 并行执行
    - 索引：conversation_history
    - 文档字段：user_id, session_id, message_id, role="assistant", content, timestamp, message_order

12. **更新MySQL会话表的updated_at字段**：
    - 更新sessions表的updated_at字段为当前时间
    - 目的：标记会话最后活跃时间

---

### 6.3 数据一致性保证

| 场景 | 一致性策略 | 说明 |
|-----|-----------|------|
| **创建会话** | 强一致性 | MySQL写入成功后才写Redis和ES，确保数据一致 |
| **保存消息** | 最终一致性 | Redis和ES并行写入，允许短暂不一致，提高性能 |
| **删除会话** | 强一致性 | MySQL删除成功后删除Redis和ES，避免孤立数据 |
| **Redis失效** | 自动恢复 | 从ES读取并回填Redis，用户无感知降级 |

**一致性保证机制**：

1. **强一致性场景（创建会话、删除会话）**：
   - 使用同步写入，确保所有数据库操作按顺序完成
   - MySQL作为事实来源，优先写入
   - 若任何步骤失败，回滚已完成的操作

2. **最终一致性场景（保存消息）**：
   - Redis和ES并行写入，不等待ES写入完成
   - 即使ES写入失败，也不影响用户体验（Redis已有数据）
   - 后台定时任务检测不一致，自动补偿

3. **降级机制**：
   - Redis失效：自动从ES读取，系统继续运行（性能降低但功能正常）
   - ES失效：仅影响历史检索，实时对话依赖Redis（核心功能不受影响）
   - Neo4j失效：图查询失败，降级为纯ES检索

---

### 6.4 数据备份与恢复

#### 备份策略

| 数据库 | 备份方式 | 备份频率 | 保留期 | 备份工具 |
|-------|---------|---------|--------|---------|
| **MySQL** | 全量备份 | 每日凌晨2点 | 30天 | mysqldump |
| **Elasticsearch** | 快照备份 | 每日凌晨3点 | 7天 | Snapshot API |
| **Neo4j** | 图数据库备份 | 每周日凌晨 | 30天 | neo4j-admin backup |
| **Redis** | RDB持久化 | 每小时 | 24小时 | SAVE命令 |

**备份存储位置**：
- 本地备份：/data/backups/{database_name}/{date}/
- 远程备份：上传至对象存储（如S3、阿里云OSS）

#### 恢复流程

**场景1：Redis数据丢失**

1. 检测Redis连接失败或数据丢失
2. 系统自动切换到降级模式：从ES读取历史数据
3. 后台任务从ES批量加载热数据到Redis
4. 为加载的数据设置过期时间（24小时）
5. 服务继续运行，用户无明显感知

**场景2：Elasticsearch索引损坏**

1. 检测ES索引不可用
2. 从最近的Snapshot恢复索引
3. 验证数据完整性（检查文档数量、字段结构）
4. 若向量索引损坏，重新构建向量索引（使用原始数据重新生成向量）
5. 切换流量到恢复后的索引

**场景3：MySQL数据丢失**

1. 停止应用服务（防止写入脏数据）
2. 从最近的mysqldump备份恢复数据
3. 验证数据完整性（检查表结构、记录数量）
4. 重新同步数据到Redis和ES：
   - 清空Redis相关Key
   - 删除ES相关索引并重新导入
5. 启动应用服务

**场景4：Neo4j图数据损坏**

1. 停止Neo4j服务
2. 使用neo4j-admin restore命令恢复备份
3. 验证图数据完整性（检查节点数量、关系数量）
4. 重建索引（为常查属性重新创建索引）
5. 启动Neo4j服务

---

## 7. 性能优化建议

### 7.1 Elasticsearch优化

| 优化项 | 建议配置 | 说明 |
|-------|---------|------|
| **分片配置** | 1-2个主分片 | 数据量百万级，过多分片会降低性能 |
| **副本配置** | 1个副本 | 提高查询性能和数据可靠性，避免单点故障 |
| **刷新间隔** | 30秒 | 默认1秒太频繁，降低实时性换取写入性能 |
| **段合并策略** | 定期合并小段 | 减少段数量，提高查询性能 |
| **向量索引算法** | HNSW | 比暴力搜索快100倍，适合百万级向量检索 |
| **查询缓存** | 启用 | 缓存常见查询结果，减少重复计算 |
| **字段数据缓存** | 限制大小 | 避免OOM，设置最大内存占用 |

**具体优化措施**：

1. **分片优化**：
   - 设置主分片为1个（数据量小于1000万条）
   - 设置副本分片为1个（提高可用性）
   - 避免过度分片（过多分片会增加协调开销）

2. **刷新间隔优化**：
   - 索引设置中配置refresh_interval为30秒
   - 降低刷新频率，提高写入吞吐量
   - 对于实时性要求不高的索引，可设置为更长时间

3. **段合并优化**：
   - 定期执行force merge操作（在低峰期）
   - 将小段合并为大段，减少段数量
   - 提高查询性能（减少打开文件数）

4. **向量检索优化**：
   - 使用HNSW算法（Hierarchical Navigable Small World）
   - 调整HNSW参数：ef_construction=100, M=16
   - 在索引速度和查询精度之间平衡

---

### 7.2 Neo4j优化

| 优化项 | 建议配置 | 说明 |
|-------|---------|------|
| **索引创建** | 为常查字段创建索引 | 如Unit.name、Network.type、System.name |
| **查询优化** | 使用PROFILE分析 | 识别慢查询，优化Cypher语句 |
| **批量导入** | 使用LOAD CSV | 大规模数据导入时比逐条插入快100倍 |
| **内存配置** | 调整堆内存和页缓存 | 根据数据规模调整，避免OOM |
| **事务批量提交** | 每1000条提交一次 | 批量提交减少事务开销 |

**具体优化措施**：

1. **索引创建**：
   - 为Unit.name创建B-tree索引（按单位名称查询）
   - 为Network.type创建B-tree索引（按网络类型过滤）
   - 为System.name创建B-tree索引（按系统名称查询）
   - 为Device.ip_address创建B-tree索引（按IP查询设备）

2. **查询优化**：
   - 使用PROFILE命令分析查询计划
   - 避免全图扫描（必须有索引或明确的起始节点）
   - 限制返回结果数量（使用LIMIT子句）
   - 优化关系遍历深度（避免过深的多跳查询）

3. **批量导入优化**：
   - 使用LOAD CSV导入CSV数据
   - 使用PERIODIC COMMIT每1000行提交一次事务
   - 导入前禁用索引，导入后重建索引

4. **内存配置优化**：
   - 堆内存：设置为物理内存的25%（最大不超过31GB）
   - 页缓存：设置为物理内存的50%
   - 避免OOM：监控内存使用，及时调整

---

### 7.3 MySQL优化

| 优化项 | 建议配置 | 说明 |
|-------|---------|------|
| **索引优化** | 为外键和常查字段创建索引 | 提高查询性能 |
| **连接池** | 使用aiomysql连接池 | 减少连接开销，提高并发性能 |
| **查询缓存** | 启用查询缓存 | 减少重复查询（MySQL 8.0已移除，需使用应用层缓存） |
| **InnoDB缓冲池** | 设置为物理内存的70% | 缓存数据和索引，减少磁盘IO |
| **慢查询日志** | 启用 | 记录执行时间超过1秒的查询 |

**具体优化措施**：

1. **索引优化**：
   - 为users表的username创建索引
   - 为sessions表的user_id创建索引（外键）
   - 为sessions表的updated_at创建索引（按更新时间排序）
   - 避免冗余索引（如已有组合索引，无需再建单列索引）

2. **连接池优化**：
   - 使用aiomysql连接池（异步IO）
   - 配置最小连接数：5
   - 配置最大连接数：20
   - 连接超时时间：10秒

3. **InnoDB配置优化**：
   - innodb_buffer_pool_size：设置为物理内存的70%
   - innodb_log_file_size：设置为256MB（提高写入性能）
   - innodb_flush_log_at_trx_commit：设置为2（每秒刷新日志，平衡性能和可靠性）

4. **慢查询优化**：
   - 启用慢查询日志：slow_query_log=ON
   - 慢查询阈值：long_query_time=1（记录超过1秒的查询）
   - 定期分析慢查询日志，优化SQL语句

---

### 7.4 Redis优化

| 优化项 | 建议配置 | 说明 |
|-------|---------|------|
| **内存限制** | 设置maxmemory | 避免OOM，根据可用内存设置 |
| **淘汰策略** | allkeys-lru | LRU淘汰最少使用的key，适合缓存场景 |
| **持久化** | RDB + AOF混合 | 兼顾性能和可靠性 |
| **连接池** | 使用redis-py连接池 | 减少连接开销，提高并发性能 |
| **键过期策略** | 主动过期 | 定期清理过期键，避免内存泄漏 |

**具体优化措施**：

1. **内存配置**：
   - maxmemory：设置为物理内存的70%（如8GB内存，设置为5.6GB）
   - maxmemory-policy：设置为allkeys-lru（LRU淘汰策略）
   - 监控内存使用：定期检查used_memory和maxmemory

2. **持久化配置**：
   - RDB持久化：每小时保存一次（save 3600 1）
   - AOF持久化：每秒同步一次（appendfsync everysec）
   - AOF重写：当AOF文件大小超过64MB时自动重写
   - 混合持久化：启用（aof-use-rdb-preamble yes）

3. **连接池配置**：
   - 使用redis-py连接池
   - 最大连接数：50
   - 连接超时时间：5秒
   - 启用连接健康检查

4. **键过期优化**：
   - 为会话消息列表设置24小时过期时间
   - 定期清理过期键（Redis自动执行）
   - 监控过期键数量（evicted_keys指标）

---

## 8. 数据初始化

### 8.1 MySQL数据库初始化

**初始化步骤描述**：

1. **创建数据库**：
   - 数据库名称：chatdb
   - 字符集：utf8mb4
   - 排序规则：utf8mb4_unicode_ci
   - 如果数据库已存在，不执行任何操作

2. **切换到chatdb数据库**

3. **创建users表**：
   - 字段：user_id（主键）、username、email、created_at、updated_at、is_active
   - 索引：主键索引（user_id）、普通索引（username、created_at）
   - 存储引擎：InnoDB
   - 字符集：utf8mb4
   - 表注释：用户表

4. **创建sessions表**：
   - 字段：session_id（主键）、user_id（外键）、name、created_at、updated_at、is_active
   - 外键约束：user_id引用users表的user_id，级联删除
   - 索引：主键索引（session_id）、外键索引（user_id）、普通索引（created_at、updated_at）
   - 存储引擎：InnoDB
   - 字符集：utf8mb4
   - 表注释：会话表

**初始化脚本位置**：scripts/init_mysql.sql

---

### 8.2 Elasticsearch索引初始化

**初始化步骤描述**：

1. **连接Elasticsearch**：
   - 地址：http://localhost:9200
   - 认证：Basic Auth，用户名elastic，密码password01

2. **创建kb_vector_store索引**：
   - 定义Mapping：包含所有字段（内容、向量、元数据等）
   - 配置分片：1个主分片，1个副本分片
   - 配置分词器：ik_max_word和ik_smart
   - 配置向量字段：1024维，cosine相似度

3. **创建conversation_history索引**：
   - 定义Mapping：包含user_id、session_id、message_id等字段
   - 配置分片：1个主分片，1个副本分片
   - 配置分词器：ik_max_word

4. **创建user_memory索引**：
   - 定义Mapping：包含query_text、query_embedding、summary_text等字段
   - 配置分片：1个主分片，1个副本分片
   - 配置向量字段：1024维，cosine相似度

**初始化脚本位置**：scripts/init_elasticsearch.py

---

### 8.3 Neo4j图数据初始化

**初始化步骤描述**：

1. **连接Neo4j**：
   - Bolt地址：bolt://localhost:7687
   - 认证：用户名neo4j，密码ChangeMe123!

2. **创建节点索引**：
   - 为Unit.name创建索引
   - 为Network.name创建索引
   - 为System.name创建索引
   - 为Device.ip_address创建索引

3. **导入初始数据**（可选）：
   - 从CSV文件导入Unit节点
   - 从CSV文件导入Network节点
   - 从CSV文件导入System节点
   - 从CSV文件导入Device节点
   - 从CSV文件导入Integrator节点
   - 创建关系：BUILDS、OPERATES、CONTAINS、RUNS_ON、INTEGRATED_BY

**初始化脚本位置**：scripts/init_neo4j.py

---

### 8.4 Redis初始化

Redis不需要显式初始化schema，但需要配置持久化和内存策略。

**配置文件位置**：/etc/redis/redis.conf

---

## 9. 监控与告警

### 9.1 监控指标

**Elasticsearch监控**：
- 集群健康状态（green/yellow/red）
- 索引文档数量
- 查询QPS和平均响应时间
- 磁盘使用率

**MySQL监控**：
- 连接数（当前/最大）
- 慢查询数量
- InnoDB缓冲池命中率
- 磁盘使用率

**Redis监控**：
- 内存使用率
- 键过期数量
- 命令QPS
- 主从同步延迟

**Neo4j监控**：
- 节点和关系数量
- 查询平均响应时间
- 内存使用率
- 磁盘使用率

### 9.2 告警规则

**Elasticsearch告警**：
- 集群状态非green超过5分钟：发送告警
- 磁盘使用率超过80%：发送告警
- 查询平均响应时间超过2秒：发送告警

**MySQL告警**：
- 连接数超过最大连接数的80%：发送告警
- 慢查询数量超过100/小时：发送告警
- 磁盘使用率超过80%：发送告警

**Redis告警**：
- 内存使用率超过90%：发送告警
- 主从同步延迟超过10秒：发送告警
- 键过期数量超过10000/分钟：发送告警

**Neo4j告警**：
- 内存使用率超过90%：发送告警
- 查询平均响应时间超过3秒：发送告警
- 磁盘使用率超过80%：发送告警

---

**相关文档**：
- [架构设计文档](./01-架构设计文档.md)
- [详细设计文档](./02-详细设计文档.md)
- [文档导航](./README.md)
