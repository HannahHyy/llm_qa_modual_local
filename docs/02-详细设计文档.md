# COMBINE_LLM 详细设计文档

## 版本：2.0
## 更新日期：2025-12-18
## 文档性质：详细设计（纯文字描述）

---

## 📌 文档说明

**详细设计文档**描述了每个模块内部的类设计、属性、方法和交互关系：
- ✅ 每个层有哪些类（抽象类、实现类）
- ✅ 每个类的成员属性和成员方法
- ✅ 同一层内类之间的关系
- ✅ 数据结构定义
- ✅ 关键流程的时序说明

**前置阅读**：请先阅读《架构设计文档》了解系统整体分层架构

**类的层次顺序**：本文档按照从底层到上层的顺序组织：
1. 横切关注点层
2. 基础设施层
3. 领域逻辑层
4. 应用服务层
5. API层

---

## 目录

1. [横切关注点层类设计](#1-横切关注点层类设计)
2. [基础设施层类设计](#2-基础设施层类设计)
3. [领域逻辑层类设计](#3-领域逻辑层类设计)
4. [应用服务层类设计](#4-应用服务层类设计)
5. [API层类设计](#5-api层类设计)
6. [关键流程时序说明](#6-关键流程时序说明)

---

## 1. 横切关注点层类设计

### 1.1 层级说明

**位置**：贯穿所有层
**特点**：提供系统级的通用功能，所有层都会使用
**包含模块**：日志管理、异常处理、配置管理、中间件

---

### 1.2 配置管理模块（config/）

#### 1.2.1 RedisSettings类

**类型**：配置类
**职责**：封装Redis服务的所有配置项

**成员属性**：
- **host**（字符串）：Redis服务器地址，默认值为"localhost"
- **port**（整数）：Redis服务端口，默认值为6379
- **db**（整数）：Redis数据库编号，默认值为0
- **password**（字符串，可选）：Redis密码，默认为空

**成员方法**：无（纯数据类）

---

#### 1.2.2 ESSettings类

**类型**：配置类
**职责**：封装Elasticsearch服务的所有配置项

**成员属性**：
- **host**（字符串）：ES服务器地址
- **port**（整数）：ES服务端口
- **username**（字符串）：ES用户名
- **password**（字符串）：ES密码
- **knowledge_index**（字符串）：知识库索引名称
- **conversation_index**（字符串）：会话历史索引名称
- **request_timeout**（浮点数）：请求超时时间（秒）

**成员方法**：无（纯数据类）

---

#### 1.2.3 MySQLSettings类

**类型**：配置类
**职责**：封装MySQL数据库的所有配置项

**成员属性**：
- **host**（字符串）：MySQL服务器地址
- **port**（整数）：MySQL服务端口
- **user**（字符串）：数据库用户名
- **password**（字符串）：数据库密码
- **database**（字符串）：数据库名称

**成员方法**：无（纯数据类）

---

#### 1.2.4 Neo4jSettings类

**类型**：配置类
**职责**：封装Neo4j图数据库的所有配置项

**成员属性**：
- **uri**（字符串）：Neo4j连接URI，包含协议和地址
- **user**（字符串）：Neo4j用户名
- **password**（字符串）：Neo4j密码

**成员方法**：无（纯数据类）

---

#### 1.2.5 LLMSettings类

**类型**：配置类
**职责**：封装大语言模型服务的所有配置项

**成员属性**：
- **base_url**（字符串）：LLM API基础地址
- **api_key**（字符串）：API密钥
- **model_name**（字符串）：模型名称，如"deepseek-v3"
- **max_tokens**（整数）：最大生成Token数
- **temperature**（浮点数）：采样温度参数

**成员方法**：无（纯数据类）

---

#### 1.2.6 EmbeddingSettings类

**类型**：配置类
**职责**：封装向量化服务的所有配置项

**成员属性**：
- **host**（字符串）：Embedding服务地址
- **port**（整数）：服务端口
- **url**（字符串）：完整的服务URL
- **request_timeout**（浮点数）：请求超时时间

**成员方法**：无（纯数据类）

---

#### 1.2.7 LangfuseSettings类

**类型**：配置类
**职责**：封装Langfuse追踪服务的配置项

**成员属性**：
- **enabled**（布尔值）：是否启用Langfuse追踪
- **public_key**（字符串，可选）：公钥
- **secret_key**（字符串，可选）：私钥

**成员方法**：无（纯数据类）

---

#### 1.2.8 Settings类（全局配置类）

**类型**：配置类
**职责**：聚合所有配置，作为全局配置入口

**成员属性**：
- **env**（字符串）：运行环境，值为"development"或"production"
- **debug**（布尔值）：是否开启调试模式
- **redis**（RedisSettings对象）：Redis配置对象
- **elasticsearch**（ESSettings对象）：ES配置对象
- **mysql**（MySQLSettings对象）：MySQL配置对象
- **neo4j**（Neo4jSettings对象）：Neo4j配置对象
- **llm**（LLMSettings对象）：LLM配置对象
- **embedding**（EmbeddingSettings对象）：Embedding配置对象
- **langfuse**（LangfuseSettings对象）：Langfuse配置对象
- **max_history_length**（整数）：保留的历史消息最大条数
- **session_timeout_minutes**（整数）：会话超时时间（分钟）

**成员方法**：
- **validate_config**：验证配置的完整性和正确性

**类之间关系**：
- Settings类聚合了所有其他配置类
- 各个配置类之间相互独立，无依赖关系

---

### 1.3 日志管理模块（core/logging.py）

#### 1.3.1 LoggerManager类

**类型**：单例类
**职责**：管理全局日志配置

**成员属性**：
- **logger**（Logger对象）：全局日志记录器实例
- **log_level**（字符串）：日志级别（DEBUG/INFO/WARNING/ERROR）
- **log_dir**（字符串）：日志文件存储目录
- **rotation_size**（字符串）：日志文件轮转大小，如"500 MB"
- **retention_days**（整数）：日志文件保留天数

**成员方法**：
- **setup_logging**：初始化日志配置，设置输出格式、轮转策略
  - 参数：环境名称（开发/生产）
  - 返回：配置好的logger对象
  - 逻辑：
    - 开发环境：输出到控制台，带颜色
    - 生产环境：输出到文件，JSON格式
    - 设置文件轮转（按大小和时间）
    - 设置压缩策略

- **get_logger**：获取logger实例（单例模式）
  - 参数：无
  - 返回：全局logger对象

**类之间关系**：
- 独立类，无依赖关系

---

### 1.4 异常处理模块（core/exceptions.py）

#### 1.4.1 BaseException类（基础异常类）

**类型**：抽象类
**职责**：定义系统所有自定义异常的基类

**成员属性**：
- **message**（字符串）：异常消息
- **error_code**（字符串）：错误码
- **details**（字典，可选）：详细错误信息

**成员方法**：
- **to_dict**：将异常转换为字典格式
  - 返回：包含error_code、message、details的字典
- **to_http_response**：将异常转换为HTTP响应格式
  - 返回：HTTP状态码和响应体

---

#### 1.4.2 ConfigError类

**类型**：异常类（继承BaseException）
**职责**：配置错误异常

**成员属性**：
- 继承BaseException的所有属性
- **config_key**（字符串）：出错的配置项名称

---

#### 1.4.3 DatabaseError类

**类型**：异常类（继承BaseException）
**职责**：数据库操作错误异常

**成员属性**：
- 继承BaseException的所有属性
- **db_type**（字符串）：数据库类型（Redis/ES/MySQL/Neo4j）
- **operation**（字符串）：操作类型（read/write/connect）

---

#### 1.4.4 LLMClientError类

**类型**：异常类（继承BaseException）
**职责**：LLM调用错误异常

**成员属性**：
- 继承BaseException的所有属性
- **model_name**（字符串）：模型名称
- **retry_count**（整数）：已重试次数

---

#### 1.4.5 IntentParseError类

**类型**：异常类（继承BaseException）
**职责**：意图解析错误异常

**成员属性**：
- 继承BaseException的所有属性
- **query**（字符串）：原始查询

---

#### 1.4.6 RetrievalError类

**类型**：异常类（继承BaseException）
**职责**：知识检索错误异常

**成员属性**：
- 继承BaseException的所有属性
- **retriever_type**（字符串）：检索器类型（ES/Neo4j/Hybrid）

**类之间关系**：
- BaseException是所有异常类的父类
- 其他异常类继承BaseException
- 异常类之间相互独立

---

### 1.5 中间件模块（core/middleware.py）

#### 1.5.1 RequestLoggingMiddleware类

**类型**：中间件类
**职责**：记录所有HTTP请求的日志

**成员属性**：
- **logger**（Logger对象）：日志记录器

**成员方法**：
- **call**：处理请求
  - 参数：request（请求对象）、call_next（下一个中间件）
  - 返回：响应对象
  - 逻辑：
    - 记录请求开始时间
    - 记录请求方法、路径、客户端IP
    - 调用下一个中间件
    - 记录响应状态码和耗时
    - 返回响应

---

#### 1.5.2 ExceptionHandlerMiddleware类

**类型**：中间件类
**职责**：统一处理所有异常，转换为HTTP响应

**成员属性**：
- **logger**（Logger对象）：日志记录器

**成员方法**：
- **call**：处理请求
  - 参数：request（请求对象）、call_next（下一个中间件）
  - 返回：响应对象或错误响应
  - 逻辑：
    - 尝试调用下一个中间件
    - 捕获自定义异常，转换为对应的HTTP状态码
    - 捕获未知异常，返回500错误
    - 记录异常日志
    - 返回统一格式的错误响应

---

#### 1.5.3 RateLimitMiddleware类

**类型**：中间件类
**职责**：限制请求频率，防止滥用

**成员属性**：
- **redis_client**（Redis客户端对象）：用于存储请求计数
- **rate_limit**（整数）：时间窗口内允许的最大请求数
- **time_window**（整数）：时间窗口大小（秒）

**成员方法**：
- **call**：处理请求
  - 参数：request（请求对象）、call_next（下一个中间件）
  - 返回：响应对象或429错误
  - 逻辑：
    - 从请求中提取user_id
    - 检查Redis中该user的请求计数
    - 如果超过限制，返回429错误
    - 否则增加计数并调用下一个中间件

**类之间关系**：
- 中间件类之间相互独立
- 按顺序链式调用
- 都依赖Logger进行日志记录

---

### 1.6 依赖注入模块（core/dependencies.py）

#### 1.6.1 DependencyContainer类

**类型**：容器类
**职责**：管理所有服务的依赖注入

**成员属性**：
- **settings**（Settings对象）：全局配置对象
- **_instances**（字典）：已创建的服务实例缓存

**成员方法**：
- **get_chat_service**：获取ChatService实例
  - 参数：无
  - 返回：ChatService对象
  - 逻辑：如果已创建则返回缓存，否则创建新实例

- **get_session_service**：获取SessionService实例
- **get_llm_client**：获取LLMClient实例
- **get_es_client**：获取ESClient实例
- **get_redis_client**：获取RedisClient实例
- **get_mysql_client**：获取MySQLClient实例
- **get_neo4j_client**：获取Neo4jClient实例
- **get_intent_parser**：获取IntentParser实例
- **get_retriever**：获取Retriever实例
- **get_prompt_builder**：获取PromptBuilder实例
- **get_knowledge_matcher**：获取KnowledgeMatcher实例
- **get_message_repository**：获取MessageRepository实例
- **get_session_repository**：获取SessionRepository实例

**类之间关系**：
- 独立类，作为依赖注入的容器
- 管理所有其他类的生命周期

---

## 2. 基础设施层类设计

### 2.1 层级说明

**位置**：第二层（从下往上）
**特点**：封装所有外部系统交互，实现领域层定义的接口
**包含模块**：外部服务客户端、数据访问Repository

---

### 2.2 客户端模块（infrastructure/clients/）

#### 2.2.1 LLMClient类

**类型**：实现类
**职责**：封装大语言模型API调用

**成员属性**：
- **base_url**（字符串）：LLM API基础地址
- **api_key**（字符串）：API密钥
- **model_name**（字符串）：使用的模型名称
- **max_tokens**（整数）：最大生成Token数
- **temperature**（浮点数）：采样温度
- **http_client**（HTTP客户端对象）：用于发送HTTP请求
- **langfuse**（Langfuse对象，可选）：追踪服务对象

**成员方法**：
- **stream_chat**：流式对话方法
  - 参数：
    - prompt（字符串）：用户提示词
    - system_prompt（字符串，可选）：系统提示词
    - user_id（字符串，可选）：用户ID（用于追踪）
    - max_retries（整数）：最大重试次数
  - 返回：异步生成器，逐块返回生成的文本
  - 逻辑：
    - 构建消息列表（system + user）
    - 如果启用Langfuse，创建trace和generation
    - 循环重试最多max_retries次
    - 发送HTTP POST请求到LLM API
    - 解析SSE格式的响应流
    - 逐块yield文本内容
    - 记录完整输出到Langfuse

- **chat**：非流式对话方法
  - 参数：与stream_chat相同
  - 返回：完整的生成文本（字符串）
  - 逻辑：类似stream_chat，但等待全部生成完成后返回

- **health_check**：健康检查方法
  - 参数：无
  - 返回：布尔值，表示服务是否健康
  - 逻辑：发送GET请求到/health端点

- **close**：关闭客户端
  - 参数：无
  - 返回：无
  - 逻辑：关闭HTTP连接

---

#### 2.2.2 ESClient类

**类型**：实现类
**职责**：封装Elasticsearch操作

**成员属性**：
- **host**（字符串）：ES服务器地址
- **port**（整数）：ES服务端口
- **username**（字符串）：用户名
- **password**（字符串）：密码
- **es_client**（Elasticsearch对象）：ES官方客户端实例
- **request_timeout**（浮点数）：请求超时时间

**成员方法**：
- **search**：搜索文档
  - 参数：
    - index（字符串）：索引名称
    - query（字典）：查询DSL
    - size（整数，可选）：返回结果数量
    - sort（列表，可选）：排序规则
  - 返回：搜索结果字典
  - 逻辑：
    - 构建完整的搜索请求
    - 发送搜索请求到ES
    - 解析响应，提取hits
    - 返回结果

- **index**：索引文档
  - 参数：
    - index（字符串）：索引名称
    - document（字典）：文档内容
    - id（字符串，可选）：文档ID
  - 返回：索引结果
  - 逻辑：
    - 发送PUT或POST请求到ES
    - 返回索引结果

- **bulk_index**：批量索引
  - 参数：
    - index（字符串）：索引名称
    - documents（列表）：文档列表
  - 返回：批量索引结果
  - 逻辑：
    - 构建bulk请求体
    - 发送bulk请求
    - 解析结果，统计成功和失败数

- **delete_by_query**：按查询删除文档
  - 参数：
    - index（字符串）：索引名称
    - query（字典）：查询DSL
  - 返回：删除结果
  - 逻辑：
    - 构建删除查询
    - 发送delete_by_query请求
    - 返回删除数量

- **ping**：检查连接
  - 参数：无
  - 返回：布尔值
  - 逻辑：发送ping请求，检查ES是否可达

---

#### 2.2.3 Neo4jClient类

**类型**：实现类
**职责**：封装Neo4j图数据库操作

**成员属性**：
- **uri**（字符串）：Neo4j连接URI
- **user**（字符串）：用户名
- **password**（字符串）：密码
- **driver**（Neo4j Driver对象）：Neo4j官方驱动实例

**成员方法**：
- **execute_query**：执行Cypher查询
  - 参数：
    - query（字符串）：Cypher查询语句
    - parameters（字典，可选）：查询参数
  - 返回：查询结果列表
  - 逻辑：
    - 创建会话
    - 执行Cypher查询
    - 解析结果为字典列表
    - 关闭会话
    - 返回结果

- **execute_write**：执行写操作
  - 参数：
    - query（字符串）：Cypher写操作语句
    - parameters（字典，可选）：参数
  - 返回：写操作结果
  - 逻辑：
    - 在写事务中执行查询
    - 提交事务
    - 返回结果

- **close**：关闭连接
  - 参数：无
  - 返回：无
  - 逻辑：关闭Neo4j驱动连接

---

#### 2.2.4 RedisClient类

**类型**：实现类
**职责**：封装Redis操作

**成员属性**：
- **host**（字符串）：Redis服务器地址
- **port**（整数）：Redis端口
- **db**（整数）：数据库编号
- **password**（字符串，可选）：密码
- **redis_client**（Redis对象）：Redis官方客户端实例

**成员方法**：
- **hset**：设置Hash字段
  - 参数：
    - key（字符串）：键名
    - field（字符串）：字段名
    - value（字符串）：值
  - 返回：操作结果
  - 逻辑：执行HSET命令

- **hget**：获取Hash字段
  - 参数：
    - key（字符串）：键名
    - field（字符串）：字段名
  - 返回：字段值（字符串）
  - 逻辑：执行HGET命令

- **hgetall**：获取Hash所有字段
  - 参数：
    - key（字符串）：键名
  - 返回：字典（field: value）
  - 逻辑：执行HGETALL命令

- **hdel**：删除Hash字段
  - 参数：
    - key（字符串）：键名
    - field（字符串）：字段名
  - 返回：删除数量
  - 逻辑：执行HDEL命令

- **rpush**：向List右侧追加元素
  - 参数：
    - key（字符串）：键名
    - value（字符串）：值
  - 返回：List长度
  - 逻辑：执行RPUSH命令

- **lrange**：获取List范围元素
  - 参数：
    - key（字符串）：键名
    - start（整数）：起始索引
    - end（整数）：结束索引
  - 返回：元素列表
  - 逻辑：执行LRANGE命令

- **llen**：获取List长度
  - 参数：
    - key（字符串）：键名
  - 返回：长度（整数）
  - 逻辑：执行LLEN命令

- **expire**：设置键过期时间
  - 参数：
    - key（字符串）：键名
    - seconds（整数）：过期时间（秒）
  - 返回：操作结果
  - 逻辑：执行EXPIRE命令

- **delete**：删除键
  - 参数：
    - key（字符串）：键名
  - 返回：删除数量
  - 逻辑：执行DEL命令

- **ping**：检查连接
  - 参数：无
  - 返回：布尔值
  - 逻辑：执行PING命令

---

#### 2.2.5 MySQLClient类

**类型**：实现类
**职责**：封装MySQL数据库操作

**成员属性**：
- **host**（字符串）：MySQL服务器地址
- **port**（整数）：MySQL端口
- **user**（字符串）：用户名
- **password**（字符串）：密码
- **database**（字符串）：数据库名称
- **connection_pool**（连接池对象）：MySQL连接池

**成员方法**：
- **execute**：执行SQL语句
  - 参数：
    - sql（字符串）：SQL语句
    - params（元组，可选）：参数
  - 返回：受影响的行数
  - 逻辑：
    - 从连接池获取连接
    - 执行SQL语句
    - 提交事务
    - 释放连接
    - 返回结果

- **query**：查询数据
  - 参数：
    - sql（字符串）：SELECT语句
    - params（元组，可选）：参数
  - 返回：结果列表（每行为字典）
  - 逻辑：
    - 从连接池获取连接
    - 执行查询
    - 获取所有结果
    - 释放连接
    - 返回结果

- **query_one**：查询单条数据
  - 参数：
    - sql（字符串）：SELECT语句
    - params（元组，可选）：参数
  - 返回：单行结果（字典）
  - 逻辑：
    - 执行查询
    - 获取第一行结果
    - 返回结果

- **close**：关闭连接池
  - 参数：无
  - 返回：无
  - 逻辑：关闭所有连接

---

#### 2.2.6 EmbeddingClient类

**类型**：实现类
**职责**：封装Embedding向量化服务

**成员属性**：
- **host**（字符串）：服务地址
- **port**（整数）：服务端口
- **url**（字符串）：完整服务URL
- **http_client**（HTTP客户端对象）：用于发送HTTP请求
- **request_timeout**（浮点数）：请求超时时间

**成员方法**：
- **get_embedding**：获取文本的向量表示
  - 参数：
    - text（字符串）：待向量化的文本
  - 返回：向量列表（浮点数列表，1024维）
  - 逻辑：
    - 构建请求体（包含text）
    - 发送POST请求到Embedding服务
    - 解析响应，提取向量
    - 返回向量

- **batch_get_embeddings**：批量获取向量
  - 参数：
    - texts（字符串列表）：待向量化的文本列表
  - 返回：向量列表（列表的列表）
  - 逻辑：
    - 构建批量请求体
    - 发送批量请求
    - 解析响应，提取所有向量
    - 返回向量列表

- **health_check**：健康检查
  - 参数：无
  - 返回：布尔值
  - 逻辑：发送GET请求到/health端点

**客户端类之间关系**：
- 所有客户端类相互独立
- 都实现统一的接口模式（如health_check方法）
- 都遵循相同的错误处理模式（抛出DatabaseError或LLMClientError）

---

### 2.3 仓储模块（infrastructure/repositories/）

#### 2.3.1 BaseRepository类（抽象类）

**类型**：抽象类
**职责**：定义Repository的统一接口

**成员属性**：无

**成员方法**（抽象方法，子类必须实现）：
- **get**：根据ID获取单个实体
  - 参数：id（字符串）
  - 返回：实体对象或None
- **create**：创建新实体
  - 参数：entity（实体对象）
  - 返回：实体ID（字符串）
- **update**：更新实体
  - 参数：id（字符串）、entity（实体对象）
  - 返回：布尔值（是否成功）
- **delete**：删除实体
  - 参数：id（字符串）
  - 返回：布尔值（是否成功）

---

#### 2.3.2 SessionRepository类（实现类）

**类型**：实现类（继承BaseRepository）
**职责**：管理会话的数据访问，同步MySQL、Redis、ES三个数据源

**成员属性**：
- **mysql_client**（MySQLClient对象）：MySQL客户端
- **redis_client**（RedisClient对象）：Redis客户端
- **es_client**（ESClient对象）：ES客户端
- **conversation_index**（字符串）：ES会话历史索引名

**成员方法**：
- **create**：创建新会话
  - 参数：session（Session对象）
  - 返回：会话ID（字符串）
  - 逻辑：
    - 生成UUID作为session_id
    - 写入MySQL的sessions表
    - 写入Redis的Hash（chat:{user_id}:sessions）
    - 写入ES的conversation_history索引
    - 返回session_id

- **get**：根据session_id获取会话
  - 参数：session_id（字符串）、user_id（字符串）
  - 返回：Session对象或None
  - 逻辑：
    - 先从Redis的Hash中获取
    - 如果Redis没有，从MySQL查询
    - 返回Session对象

- **list_by_user**：获取用户的所有会话
  - 参数：user_id（字符串）
  - 返回：Session对象列表
  - 逻辑：
    - 从Redis的Hash中获取所有会话
    - 如果Redis没有，从MySQL查询
    - 返回会话列表

- **update**：更新会话
  - 参数：session_id（字符串）、session（Session对象）
  - 返回：布尔值
  - 逻辑：
    - 更新MySQL的sessions表
    - 更新Redis的Hash
    - 更新ES的索引
    - 返回是否成功

- **delete**：删除会话
  - 参数：session_id（字符串）、user_id（字符串）
  - 返回：布尔值
  - 逻辑：
    - 从MySQL删除
    - 从Redis删除Hash字段
    - 从Redis删除消息List
    - 从ES删除（按session_id查询删除）
    - 返回是否成功

---

#### 2.3.3 MessageRepository类（实现类）

**类型**：实现类（不继承BaseRepository，因为接口不完全匹配）
**职责**：管理消息的数据访问，实现Redis优先、ES备用的双层存储

**成员属性**：
- **redis_client**（RedisClient对象）：Redis客户端
- **es_client**（ESClient对象）：ES客户端
- **conversation_index**（字符串）：ES会话历史索引名

**成员方法**：
- **save**：保存消息
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
    - role（字符串）：角色（user/assistant）
    - content（字符串）：消息内容
  - 返回：无
  - 逻辑：
    - 生成消息对象（包含role、content、timestamp）
    - 同时写入Redis的List（chat:{user_id}:session:{session_id}:messages）
    - 同时写入ES的conversation_history索引
    - 如果ES写入失败，记录日志但不影响Redis写入

- **get_messages**：获取会话的所有消息
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
  - 返回：Message对象列表
  - 逻辑：
    - 先从Redis的List中获取（LRANGE 0 -1）
    - 如果Redis有数据，直接返回
    - 如果Redis没有数据，从ES查询
    - 从ES查询后，回填到Redis（RPUSH）
    - 设置Redis的过期时间（24小时）
    - 返回消息列表

- **get_recent_messages**：获取最近N条消息
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
    - limit（整数）：获取数量
  - 返回：Message对象列表
  - 逻辑：
    - 从Redis的List中获取最近N条（LRANGE -N -1）
    - 如果Redis没有，从ES查询并回填
    - 返回消息列表

- **delete_messages**：删除会话的所有消息
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
  - 返回：布尔值
  - 逻辑：
    - 从Redis删除List
    - 从ES删除（按session_id查询删除）
    - 返回是否成功

---

#### 2.3.4 KnowledgeRepository类（实现类）

**类型**：实现类（不继承BaseRepository）
**职责**：管理知识库的数据访问，封装ES知识索引操作

**成员属性**：
- **es_client**（ESClient对象）：ES客户端
- **knowledge_index**（字符串）：知识库索引名

**成员方法**：
- **search_by_vector**：向量检索
  - 参数：
    - query_vector（浮点数列表）：查询向量（1024维）
    - top_k（整数）：返回Top-K结果
    - filters（字典，可选）：元数据过滤条件
  - 返回：Knowledge对象列表
  - 逻辑：
    - 构建ES的script_score查询（余弦相似度）
    - 应用过滤条件（如标准、级别）
    - 执行查询
    - 解析结果为Knowledge对象列表
    - 返回结果

- **search_by_keyword**：关键词检索
  - 参数：
    - query_text（字符串）：查询文本
    - top_k（整数）：返回Top-K结果
    - filters（字典，可选）：元数据过滤条件
  - 返回：Knowledge对象列表
  - 逻辑：
    - 构建ES的multi_match查询（BM25）
    - 应用过滤条件
    - 执行查询
    - 解析结果为Knowledge对象列表
    - 返回结果

- **search_hybrid**：混合检索
  - 参数：
    - query_text（字符串）：查询文本
    - query_vector（浮点数列表）：查询向量
    - top_k（整数）：返回Top-K结果
    - bm25_weight（浮点数）：BM25权重
    - vector_weight（浮点数）：向量权重
    - filters（字典，可选）：元数据过滤条件
  - 返回：Knowledge对象列表
  - 逻辑：
    - 构建ES的bool查询，should子句包含：
      - multi_match查询（权重bm25_weight）
      - script_score查询（权重vector_weight）
    - 应用过滤条件
    - 执行查询
    - 解析结果为Knowledge对象列表
    - 返回结果

- **get_by_id**：根据clause_key获取知识
  - 参数：clause_key（字符串）
  - 返回：Knowledge对象或None
  - 逻辑：
    - 根据clause_key查询ES
    - 解析结果为Knowledge对象
    - 返回结果

**Repository类之间关系**：
- BaseRepository定义统一接口
- SessionRepository实现BaseRepository
- MessageRepository和KnowledgeRepository不继承BaseRepository（接口不匹配）
- 所有Repository类都依赖对应的Client类
- Repository类之间相互独立，无依赖关系

---

## 3. 领域逻辑层类设计

### 3.1 层级说明

**位置**：第三层（从下往上）
**特点**：纯业务逻辑，不依赖框架和外部系统
**包含模块**：领域模型、领域服务、策略类

---

### 3.2 领域模型模块（domain/models/）

#### 3.2.1 Message类

**类型**：领域模型类（数据类）
**职责**：表示一条对话消息

**成员属性**：
- **role**（字符串）：角色，值为"user"或"assistant"
- **content**（字符串）：消息内容
- **timestamp**（日期时间对象）：消息时间戳
- **metadata**（字典，可选）：元数据，如消息来源等

**成员方法**：
- **to_dict**：转换为字典格式
  - 返回：包含所有属性的字典
- **from_dict**：从字典创建Message对象（类方法）
  - 参数：data（字典）
  - 返回：Message对象

---

#### 3.2.2 Session类

**类型**：领域模型类
**职责**：表示一个对话会话

**成员属性**：
- **id**（字符串）：会话ID（UUID）
- **user_id**（字符串）：用户ID
- **name**（字符串）：会话名称
- **created_at**（日期时间对象）：创建时间
- **updated_at**（日期时间对象）：更新时间
- **is_active**（布尔值）：是否活跃

**成员方法**：
- **to_dict**：转换为字典格式
- **from_dict**：从字典创建Session对象（类方法）

---

#### 3.2.3 Intent类

**类型**：领域模型类
**职责**：表示用户查询的意图解析结果

**成员属性**：
- **query**（字符串）：原始用户查询
- **rewritten_query**（字符串）：重写后的查询
- **intent_type**（字符串）：意图类型，值为"es"、"neo4j"、"hybrid"或"none"
- **entities**（字符串列表）：提取的实体
- **standards**（字符串列表）：识别的标准
- **requirement_items**（字符串列表）：要求项
- **retrieval_strategy**（字符串）：检索策略，值为"keyword"、"semantic"或"hybrid"
- **no_standard_query**（布尔值）：是否无需标准查询

**成员方法**：
- **to_dict**：转换为字典格式
- **from_dict**：从字典创建Intent对象（类方法）

---

#### 3.2.4 Knowledge类

**类型**：领域模型类
**职责**：表示一条检索到的知识

**成员属性**：
- **clause_key**（字符串）：条款唯一标识
- **content**（字符串）：条款内容
- **embedding_content**（字符串，可选）：用于展示的格式化内容
- **source_standard**（字符串）：来源标准名称
- **identifier**（字符串）：标准编号
- **section_levels**（字典）：章节层级（level1-level5）
- **requirement_item**（字符串，可选）：要求项
- **applicability_level**（字符串）：适用级别
- **score**（浮点数）：检索相似度分数
- **retrieval_path**（字符串）：检索路径（keyword_search/semantic_search/hybrid_combined）

**成员方法**：
- **to_dict**：转换为字典格式
- **from_dict**：从字典创建Knowledge对象（类方法）

**领域模型类之间关系**：
- Message和Session有关联关系（一个Session包含多个Message）
- Intent和Knowledge无直接关系
- 所有模型类都是纯数据类，无业务逻辑

---

### 3.3 意图解析服务模块（domain/services/intent_parser/）

#### 3.3.1 BaseIntentParser类（抽象类）

**类型**：抽象类
**职责**：定义意图解析器的统一接口

**成员属性**：无

**成员方法**（抽象方法）：
- **parse**：解析用户意图
  - 参数：
    - query（字符串）：用户查询
    - history（Message对象列表）：历史消息
    - stream_callback（异步回调函数，可选）：流式输出回调
  - 返回：Intent对象
  - 逻辑：由子类实现

**成员方法**（具体方法，子类可重写）：
- **extract_entities**：提取实体
  - 参数：text（字符串）
  - 返回：实体列表
  - 逻辑：基于规则的简单提取（子类可重写为更复杂的实现）

- **rewrite_query**：重写查询
  - 参数：
    - query（字符串）：原始查询
    - entities（字符串列表）：已提取的实体
  - 返回：重写后的查询（字符串）
  - 逻辑：基于实体进行同义词扩展（子类可重写）

---

#### 3.3.2 ESIntentParser类（实现类）

**类型**：实现类（继承BaseIntentParser）
**职责**：解析法规标准查询的意图

**成员属性**：
- **llm_client**（LLMClient对象）：LLM客户端，用于调用大模型解析
- **prompt_template**（字符串）：意图解析的提示词模板

**成员方法**：
- **parse**：解析ES查询意图（重写父类方法）
  - 参数：
    - query（字符串）：用户查询
    - history（Message对象列表）：历史消息
    - stream_callback（异步回调函数，可选）：流式输出回调
  - 返回：Intent对象
  - 逻辑：
    - 格式化历史消息（最近2条）
    - 构建提示词（将query和history_text填入模板）
    - 调用LLM的stream_chat方法
    - 逐块收集LLM输出，如果有回调则调用
    - 解析LLM输出的JSON结果
    - 提取rewritten_query、standards、entities、requirement_items、retrieval_strategy
    - 构建Intent对象（intent_type设为"es"）
    - 返回Intent对象
    - 如果解析失败，返回默认Intent

- **format_history**：格式化历史消息为文本（私有方法）
  - 参数：
    - history（Message对象列表）
    - max_turns（整数）：最多保留轮次
  - 返回：格式化后的文本（字符串）
  - 逻辑：
    - 取最近max_turns条消息
    - 格式化为"用户: xxx\n助手: xxx"的形式
    - 返回文本

- **extract_json**：从LLM输出中提取JSON（私有方法）
  - 参数：text（字符串）
  - 返回：JSON字符串
  - 逻辑：
    - 尝试提取```json ... ```中的内容
    - 如果没有，尝试提取{ ... }
    - 返回JSON字符串

---

#### 3.3.3 Neo4jIntentParser类（实现类）

**类型**：实现类（继承BaseIntentParser）
**职责**：解析业务图谱查询的意图

**成员属性**：
- **llm_client**（LLMClient对象）：LLM客户端
- **prompt_template**（字符串）：Neo4j意图解析的提示词模板

**成员方法**：
- **parse**：解析Neo4j查询意图（重写父类方法）
  - 参数：与ESIntentParser相同
  - 返回：Intent对象
  - 逻辑：
    - 格式化历史消息
    - 构建提示词（强调提取业务实体和关系）
    - 调用LLM进行解析
    - 提取实体（单位、网络、系统、设备等）
    - 提取关系（建设、运营、集成等）
    - 构建Intent对象（intent_type设为"neo4j"）
    - 返回Intent对象

- **extract_entities**：提取业务实体（重写父类方法）
  - 参数：text（字符串）
  - 返回：实体列表
  - 逻辑：
    - 识别单位名称（如"河北分公司"）
    - 识别网络名称（如"核心网"）
    - 识别系统名称（如"CRM系统"）
    - 返回实体列表

- **extract_relations**：提取关系（新方法）
  - 参数：text（字符串）
  - 返回：关系列表
  - 逻辑：
    - 识别动词（建设、运营、集成、负责等）
    - 返回关系列表

**意图解析类之间关系**：
- BaseIntentParser定义统一接口
- ESIntentParser实现ES查询意图解析
- Neo4jIntentParser实现Neo4j查询意图解析
- 两个实现类相互独立
- 都依赖LLMClient进行解析

---

### 3.4 知识检索服务模块（domain/services/retrieval/）

#### 3.4.1 BaseRetriever类（抽象类）

**类型**：抽象类
**职责**：定义检索器的统一接口

**成员属性**：无

**成员方法**（抽象方法）：
- **retrieve**：根据意图检索知识
  - 参数：intent（Intent对象）
  - 返回：Knowledge对象列表
  - 逻辑：由子类实现

**成员方法**（具体方法）：
- **rank_results**：对检索结果排序
  - 参数：results（Knowledge对象列表）
  - 返回：排序后的Knowledge对象列表
  - 逻辑：按score降序排序

---

#### 3.4.2 ESRetriever类（实现类）

**类型**：实现类（继承BaseRetriever）
**职责**：从Elasticsearch检索法规知识

**成员属性**：
- **knowledge_repository**（KnowledgeRepository对象）：知识库仓储
- **embedding_client**（EmbeddingClient对象）：向量化服务客户端
- **top_k**（整数）：返回Top-K结果，默认10
- **strategy_weights**（字典）：检索策略权重配置，如：
  - "keyword": {bm25: 0.8, vector: 0.2}
  - "semantic": {bm25: 0.2, vector: 0.8}
  - "hybrid": {bm25: 0.6, vector: 0.4}

**成员方法**：
- **retrieve**：ES检索实现（重写父类方法）
  - 参数：intent（Intent对象）
  - 返回：Knowledge对象列表
  - 逻辑：
    - 调用embedding_client获取query的向量
    - 根据intent.retrieval_strategy确定权重
    - 构建过滤条件（如果intent有standards或requirement_items）
    - 根据策略选择检索方法：
      - 如果是"keyword"：主要用search_by_keyword
      - 如果是"semantic"：主要用search_by_vector
      - 如果是"hybrid"：用search_hybrid
    - 调用knowledge_repository的对应方法
    - 获取检索结果
    - 对结果排序
    - 返回Top-K结果

---

#### 3.4.3 Neo4jRetriever类（实现类）

**类型**：实现类（继承BaseRetriever）
**职责**：从Neo4j图数据库检索业务信息

**成员属性**：
- **neo4j_client**（Neo4jClient对象）：Neo4j客户端
- **max_results**（整数）：最大返回结果数

**成员方法**：
- **retrieve**：Neo4j检索实现（重写父类方法）
  - 参数：intent（Intent对象）
  - 返回：Knowledge对象列表（这里Knowledge表示查询到的业务信息）
  - 逻辑：
    - 根据intent中的entities和relations构建Cypher查询
    - 例如：如果实体是"河北分公司"，关系是"建设"，生成查询：
      - MATCH (u:Unit {name: '河北分公司'})-[:BUILDS]->(n:Network)
      - RETURN u, n
    - 调用neo4j_client执行查询
    - 解析查询结果
    - 将结果格式化为Knowledge对象（content包含查询到的信息）
    - 返回结果列表

- **build_cypher_query**：构建Cypher查询（私有方法）
  - 参数：
    - entities（字符串列表）：实体列表
    - relations（字符串列表）：关系列表
  - 返回：Cypher查询字符串
  - 逻辑：
    - 根据实体类型选择节点标签（Unit/Network/System/Device）
    - 根据关系选择关系类型（BUILDS/OPERATES/CONTAINS/RUNS_ON）
    - 构建MATCH子句
    - 构建RETURN子句
    - 返回完整Cypher查询

- **format_neo4j_results**：格式化Neo4j结果（私有方法）
  - 参数：results（字典列表）
  - 返回：Knowledge对象列表
  - 逻辑：
    - 遍历每个结果
    - 提取节点属性
    - 格式化为可读文本（如"河北分公司建设了核心网"）
    - 包装为Knowledge对象
    - 返回列表

---

#### 3.4.4 HybridRetriever类（实现类）

**类型**：实现类（继承BaseRetriever）
**职责**：协调ES和Neo4j的混合检索

**成员属性**：
- **es_retriever**（ESRetriever对象）：ES检索器
- **neo4j_retriever**（Neo4jRetriever对象）：Neo4j检索器

**成员方法**：
- **retrieve**：混合检索实现（重写父类方法）
  - 参数：intent（Intent对象）
  - 返回：Knowledge对象列表
  - 逻辑：
    - 首先调用neo4j_retriever.retrieve(intent)获取业务信息
    - 将业务信息结果拼接到intent.query中，形成增强查询
    - 创建新的Intent对象，query为增强后的查询
    - 调用es_retriever.retrieve(增强Intent)获取法规知识
    - 合并两部分结果（Neo4j结果在前，ES结果在后）
    - 返回合并后的列表

**检索器类之间关系**：
- BaseRetriever定义统一接口
- ESRetriever、Neo4jRetriever独立实现各自的检索逻辑
- HybridRetriever聚合ES和Neo4j检索器，实现混合检索
- ES检索器依赖KnowledgeRepository和EmbeddingClient
- Neo4j检索器依赖Neo4jClient

---

### 3.5 其他领域服务模块

#### 3.5.1 PromptBuilder类

**类型**：领域服务类
**职责**：构建发送给LLM的完整提示词

**成员属性**：
- **prompt_template**（字符串）：提示词模板
- **max_history_length**（整数）：最多包含的历史消息条数
- **max_knowledge_length**（整数）：最多包含的知识字符数

**成员方法**：
- **build**：构建完整提示词
  - 参数：
    - query（字符串）：用户查询
    - history（Message对象列表）：历史消息
    - knowledge_list（Knowledge对象列表）：检索到的知识
  - 返回：完整提示词（字符串）
  - 逻辑：
    - 格式化历史消息（只保留最近max_history_length条）
    - 格式化知识（提取embedding_content，拼接）
    - 截断知识文本（不超过max_knowledge_length字符）
    - 将history_text、knowledge_text、query填入模板
    - 返回完整提示词

- **format_history**：格式化历史消息（私有方法）
  - 参数：
    - history（Message对象列表）
    - max_length（整数）
  - 返回：格式化文本（字符串）
  - 逻辑：
    - 取最近max_length条消息
    - 过滤掉<think>和<knowledge>标签内容（只保留<data>）
    - 格式化为"用户: xxx\n助手: xxx"
    - 返回文本

- **format_knowledge**：格式化知识（私有方法）
  - 参数：knowledge_list（Knowledge对象列表）
  - 返回：格式化文本（字符串）
  - 逻辑：
    - 遍历知识列表
    - 提取每条知识的embedding_content
    - 拼接为"【标准】内容\n【标准】内容\n..."格式
    - 返回文本

---

#### 3.5.2 KnowledgeMatcher类

**类型**：领域服务类
**职责**：匹配LLM输出与检索到的知识，找出最相关的知识

**成员属性**：
- **max_results**（整数）：最多返回几条匹配知识

**成员方法**：
- **match**：匹配LLM输出与知识
  - 参数：
    - llm_output（字符串）：LLM生成的回答
    - knowledge_list（Knowledge对象列表）：检索到的知识列表
  - 返回：匹配的知识列表（字符串列表，格式化后的知识）
  - 逻辑：
    - 使用BM25算法计算llm_output与每条knowledge的相似度
    - 对knowledge按相似度降序排序
    - 取Top max_results条
    - 格式化为展示格式（包含标准编号、章节、内容）
    - 返回格式化后的知识列表

- **calculate_bm25_score**：计算BM25分数（私有方法）
  - 参数：
    - query（字符串）：查询文本
    - document（字符串）：文档文本
  - 返回：BM25分数（浮点数）
  - 逻辑：
    - 分词query和document
    - 计算词频TF
    - 计算逆文档频率IDF
    - 应用BM25公式计算分数
    - 返回分数

- **format_knowledge_for_display**：格式化知识用于展示（私有方法）
  - 参数：knowledge（Knowledge对象）
  - 返回：格式化字符串
  - 逻辑：
    - 提取标准编号、章节层级、内容
    - 格式化为易读的字符串
    - 返回格式化结果

---

#### 3.5.3 MemoryService类

**类型**：领域服务类
**职责**：管理用户的长期记忆

**成员属性**：
- **es_client**（ESClient对象）：ES客户端
- **embedding_client**（EmbeddingClient对象）：向量化客户端
- **user_memory_index**（字符串）：用户记忆索引名

**成员方法**：
- **retrieve_similar_memories**：检索相似的历史记忆
  - 参数：
    - user_id（字符串）：用户ID
    - query（字符串）：当前查询
    - top_k（整数）：返回Top-K条记忆
  - 返回：记忆列表（字典列表，包含query_text、summary_text等）
  - 逻辑：
    - 调用embedding_client获取query的向量
    - 在ES的user_memory索引中进行向量检索
    - 过滤user_id（只查该用户的记忆）
    - 返回Top-K条最相似的记忆
    - 返回记忆列表

- **save_memory**：保存用户记忆
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
    - query_text（字符串）：用户查询
    - summary_text（字符串）：会话摘要
    - assistant_response（字符串）：助手回答
    - satisfaction_score（整数，可选）：满意度评分
  - 返回：无
  - 逻辑：
    - 调用embedding_client获取query_text的向量
    - 构建记忆文档
    - 写入ES的user_memory索引
    - 返回

- **generate_summary**：生成会话摘要（私有方法）
  - 参数：
    - messages（Message对象列表）：会话消息
  - 返回：摘要文本（字符串）
  - 逻辑：
    - 提取关键信息
    - 使用LLM生成简洁摘要
    - 返回摘要

**其他服务类之间关系**：
- PromptBuilder、KnowledgeMatcher、MemoryService相互独立
- PromptBuilder依赖Message和Knowledge模型
- KnowledgeMatcher依赖Knowledge模型
- MemoryService依赖ESClient和EmbeddingClient

---

### 3.6 策略模块（domain/strategies/）

#### 3.6.1 IntentRoutingStrategy类

**类型**：策略类
**职责**：决定使用哪种检索模式（ES/Neo4j/Hybrid/None）

**成员属性**：
- **llm_client**（LLMClient对象）：LLM客户端
- **prompt_template**（字符串）：路由决策的提示词模板

**成员方法**：
- **route**：决定路由
  - 参数：
    - query（字符串）：用户查询
    - history（Message对象列表）：历史消息
    - stream_callback（异步回调函数，可选）：流式输出回调
  - 返回：路由决策（字符串："es"/"neo4j"/"hybrid"/"none"）
  - 逻辑：
    - 格式化历史消息
    - 构建提示词（让LLM判断查询类型）
    - 调用LLM进行判断
    - 解析LLM的决策结果
    - 如果提到业务情况且提到法规标准，返回"hybrid"
    - 如果只提到业务情况，返回"neo4j"
    - 如果只提到法规标准，返回"es"
    - 如果都不涉及，返回"none"

**策略类之间关系**：
- IntentRoutingStrategy是独立的策略类
- 依赖LLMClient进行决策

---

## 4. 应用服务层类设计

### 4.1 层级说明

**位置**：第四层（从下往上）
**特点**：编排领域服务，完成完整的业务流程
**包含模块**：对话服务、会话管理服务、流式响应服务

---

### 4.2 应用服务类

#### 4.2.1 ChatService类

**类型**：应用服务类
**职责**：编排完整的对话流程

**成员属性**：
- **session_service**（SessionService对象）：会话管理服务
- **intent_routing_strategy**（IntentRoutingStrategy对象）：意图路由策略
- **es_intent_parser**（BaseIntentParser对象）：ES意图解析器
- **neo4j_intent_parser**（BaseIntentParser对象）：Neo4j意图解析器
- **es_retriever**（BaseRetriever对象）：ES检索器
- **neo4j_retriever**（BaseRetriever对象）：Neo4j检索器
- **hybrid_retriever**（BaseRetriever对象）：混合检索器
- **prompt_builder**（PromptBuilder对象）：提示词构建器
- **knowledge_matcher**（KnowledgeMatcher对象）：知识匹配器
- **llm_client**（LLMClient对象）：LLM客户端
- **message_repository**（MessageRepository对象）：消息仓储
- **streaming_service**（StreamingService对象）：流式响应服务

**成员方法**：
- **handle_chat_stream**：处理流式对话请求（主方法）
  - 参数：
    - user_id（字符串）：用户ID
    - session_id（字符串）：会话ID
    - question（字符串）：用户问题
    - scene_id（整数）：场景ID（1=混合, 2=Neo4j, 3=ES）
    - background_tasks（后台任务对象）：用于异步存储
  - 返回：异步生成器，逐块返回字节流（SSE格式）
  - 逻辑：
    - 根据scene_id选择调用哪个流程：
      - scene_id=1：调用hybrid_flow
      - scene_id=2：调用neo4j_flow
      - scene_id=3：调用es_flow
    - 逐块yield响应
    - 返回

- **es_flow**：ES查询流程（私有方法）
  - 参数：
    - user_id、session_id、question、background_tasks
  - 返回：异步生成器
  - 逻辑：
    - 调用session_service加载历史消息
    - 调用streaming_service输出<think>开始标签
    - 调用es_intent_parser解析意图（流式输出思考过程）
    - 调用streaming_service输出<think>结束标签
    - 调用es_retriever检索知识
    - 调用prompt_builder构建提示词
    - 调用streaming_service输出<data>开始标签
    - 调用llm_client.stream_chat生成回答（逐块yield）
    - 调用streaming_service输出<data>结束标签
    - 调用knowledge_matcher匹配知识
    - 如果有匹配知识，调用streaming_service输出<knowledge>内容
    - 在后台任务中异步保存消息到message_repository
    - 返回

- **neo4j_flow**：Neo4j查询流程（私有方法）
  - 参数：同es_flow
  - 返回：异步生成器
  - 逻辑：
    - 调用session_service加载历史消息
    - 调用streaming_service输出<think>开始标签
    - 调用neo4j_intent_parser解析意图（流式输出）
    - 调用streaming_service输出<think>结束标签
    - 调用neo4j_retriever检索业务信息
    - 调用prompt_builder构建提示词
    - 调用streaming_service输出<data>开始标签
    - 调用llm_client.stream_chat生成回答（逐块yield）
    - 调用streaming_service输出<data>结束标签
    - 在后台任务中异步保存消息
    - 返回

- **hybrid_flow**：混合查询流程（私有方法）
  - 参数：同es_flow
  - 返回：异步生成器
  - 逻辑：
    - 调用session_service加载历史消息
    - 调用streaming_service输出<think>开始标签
    - 调用intent_routing_strategy进行路由决策
    - 输出路由决策结果
    - 调用streaming_service输出<think>结束标签
    - 调用hybrid_retriever检索（内部会先Neo4j后ES）
    - 调用prompt_builder构建提示词
    - 调用streaming_service输出<data>开始标签
    - 调用llm_client.stream_chat生成回答
    - 调用streaming_service输出<data>结束标签
    - 调用knowledge_matcher匹配知识
    - 输出<knowledge>内容
    - 在后台任务中异步保存消息
    - 返回

---

#### 4.2.2 SessionService类

**类型**：应用服务类
**职责**：管理会话的生命周期

**成员属性**：
- **session_repository**（SessionRepository对象）：会话仓储
- **message_repository**（MessageRepository对象）：消息仓储

**成员方法**：
- **create_session**：创建新会话
  - 参数：
    - user_id（字符串）：用户ID
    - name（字符串，可选）：会话名称
  - 返回：会话ID（字符串）
  - 逻辑：
    - 创建Session对象
    - 调用session_repository.create保存会话
    - 返回session_id

- **list_sessions**：获取用户的所有会话
  - 参数：user_id（字符串）
  - 返回：Session对象列表
  - 逻辑：
    - 调用session_repository.list_by_user获取会话列表
    - 返回列表

- **get_messages**：获取会话的历史消息
  - 参数：
    - user_id（字符串）
    - session_id（字符串）
  - 返回：Message对象列表
  - 逻辑：
    - 调用message_repository.get_messages获取消息
    - 返回消息列表

- **delete_session**：删除会话
  - 参数：
    - user_id（字符串）
    - session_id（字符串）
  - 返回：布尔值（是否成功）
  - 逻辑：
    - 调用session_repository.delete删除会话
    - 调用message_repository.delete_messages删除消息
    - 返回是否成功

- **ensure_session**：确保会话存在
  - 参数：
    - user_id（字符串）
    - session_id（字符串）
  - 返回：无（如果不存在抛出异常）
  - 逻辑：
    - 调用session_repository.get获取会话
    - 如果不存在，抛出KeyError异常

---

#### 4.2.3 StreamingService类

**类型**：应用服务类
**职责**：管理流式响应的格式化和缓冲

**成员属性**：
- **buffer_size**（整数）：缓冲区大小

**成员方法**：
- **stream_think_start**：输出<think>开始标签
  - 参数：无
  - 返回：异步生成器，yield字节流
  - 逻辑：
    - 构建JSON数据：{"content": "<think>开始分析...\n", "message_type": 1}
    - 格式化为SSE格式：data:{JSON}\n\n
    - 编码为UTF-8字节流
    - yield字节流

- **stream_think_end**：输出<think>结束标签
  - 参数：无
  - 返回：异步生成器
  - 逻辑：
    - 构建JSON数据：{"content": "</think>\n", "message_type": 1}
    - 格式化为SSE格式
    - yield字节流

- **stream_data_start**：输出<data>开始标签
  - 参数：无
  - 返回：异步生成器
  - 逻辑：
    - 构建JSON数据：{"content": "<data>\n", "message_type": 2}
    - 格式化为SSE格式
    - yield字节流

- **stream_data_end**：输出<data>结束标签
  - 参数：无
  - 返回：异步生成器
  - 逻辑：
    - 构建JSON数据：{"content": "\n</data>", "message_type": 2}
    - 格式化为SSE格式
    - yield字节流

- **stream_knowledge**：输出<knowledge>内容
  - 参数：matched_knowledge（字符串列表）
  - 返回：异步生成器
  - 逻辑：
    - 构建knowledge字典结构
    - 序列化为JSON
    - 构建JSON数据：{"content": JSON, "message_type": 3}
    - 格式化为SSE格式
    - yield字节流

- **stream_error**：输出错误信息
  - 参数：error_message（字符串）
  - 返回：异步生成器
  - 逻辑：
    - 构建JSON数据：{"content": "<data>\n错误: {error_message}\n</data>", "message_type": 4}
    - 格式化为SSE格式
    - yield字节流

- **format_chunk**：格式化单个文本块
  - 参数：
    - content（字符串）：内容
    - message_type（整数）：消息类型
  - 返回：字节流
  - 逻辑：
    - 构建JSON数据：{"content": content, "message_type": message_type}
    - 格式化为SSE格式
    - 编码为UTF-8字节流
    - 返回字节流

**应用服务类之间关系**：
- ChatService是核心编排者，依赖SessionService和StreamingService
- ChatService聚合了所有领域服务（IntentParser、Retriever等）
- SessionService依赖SessionRepository和MessageRepository
- StreamingService是独立的格式化服务
- 三个服务类相互独立，无循环依赖

---

## 5. API层类设计

### 5.1 层级说明

**位置**：第五层（最上层）
**特点**：接收HTTP请求，参数验证，返回响应
**包含模块**：路由定义、请求/响应Schema

---

### 5.2 Schema模块（api/schemas/）

#### 5.2.1 ChatRequest类

**类型**：请求Schema类（数据验证类）
**职责**：验证对话请求的参数

**成员属性**：
- **message**（字符串）：用户消息，长度限制1-4000字符

**成员方法**：无（纯验证类）

---

#### 5.2.2 ChatStreamChunk类

**类型**：响应Schema类
**职责**：定义流式响应块的格式

**成员属性**：
- **content**（字符串）：内容块
- **message_type**（整数）：消息类型，值为1-4：
  - 1: think（思考过程）
  - 2: data（回答内容）
  - 3: knowledge（知识来源）
  - 4: error（错误信息）

**成员方法**：无

---

#### 5.2.3 SessionCreateRequest类

**类型**：请求Schema类
**职责**：验证创建会话的请求参数

**成员属性**：
- **name**（字符串，可选）：会话名称，长度限制0-200字符

**成员方法**：无

---

#### 5.2.4 SessionResponse类

**类型**：响应Schema类
**职责**：定义会话响应的格式

**成员属性**：
- **session_id**（字符串）：会话ID
- **user_id**（字符串）：用户ID
- **name**（字符串）：会话名称
- **created_at**（字符串）：创建时间（ISO格式）
- **updated_at**（字符串，可选）：更新时间

**成员方法**：无

---

#### 5.2.5 MessageResponse类

**类型**：响应Schema类
**职责**：定义消息响应的格式

**成员属性**：
- **role**（字符串）：角色（user/assistant）
- **content**（字符串）：消息内容
- **timestamp**（字符串）：时间戳（ISO格式）

**成员方法**：无

**Schema类之间关系**：
- 所有Schema类相互独立
- 都是纯数据验证类，无业务逻辑

---

### 5.3 路由模块（api/v1/）

#### 5.3.1 ChatRouter类

**类型**：路由类
**职责**：定义对话相关的API路由

**路由方法**：
- **chat_stream**：流式对话接口
  - HTTP方法：POST
  - 路径：/api/v1/chat/stream
  - 查询参数：
    - user_id（字符串，必填）：用户ID
    - session_id（字符串，必填）：会话ID
    - scene_id（整数，可选）：场景ID，默认1
  - 请求体：ChatRequest（包含message）
  - 响应：StreamingResponse（SSE格式）
  - 逻辑：
    - 验证请求参数（使用Pydantic）
    - 注入ChatService（通过依赖注入）
    - 调用chat_service.handle_chat_stream
    - 返回流式响应
    - 异常处理：捕获异常，返回500错误

---

#### 5.3.2 SessionRouter类

**类型**：路由类
**职责**：定义会话管理相关的API路由

**路由方法**：
- **create_session**：创建会话接口
  - HTTP方法：POST
  - 路径：/api/v1/sessions
  - 查询参数：user_id（字符串，必填）
  - 请求体：SessionCreateRequest
  - 响应：SessionResponse
  - 逻辑：
    - 验证参数
    - 注入SessionService
    - 调用session_service.create_session
    - 返回会话信息

- **list_sessions**：获取会话列表接口
  - HTTP方法：GET
  - 路径：/api/v1/sessions
  - 查询参数：user_id（字符串，必填）
  - 响应：SessionResponse列表
  - 逻辑：
    - 验证参数
    - 注入SessionService
    - 调用session_service.list_sessions
    - 返回会话列表

- **get_messages**：获取会话消息接口
  - HTTP方法：GET
  - 路径：/api/v1/sessions/{session_id}/messages
  - 路径参数：session_id（字符串）
  - 查询参数：user_id（字符串，必填）
  - 响应：MessageResponse列表
  - 逻辑：
    - 验证参数
    - 注入SessionService
    - 调用session_service.ensure_session确保会话存在
    - 调用session_service.get_messages获取消息
    - 返回消息列表

- **delete_session**：删除会话接口
  - HTTP方法：DELETE
  - 路径：/api/v1/sessions/{session_id}
  - 路径参数：session_id（字符串）
  - 查询参数：user_id（字符串，必填）
  - 响应：成功消息（JSON）
  - 逻辑：
    - 验证参数
    - 注入SessionService
    - 调用session_service.ensure_session确保会话存在
    - 调用session_service.delete_session删除会话
    - 返回成功消息

---

#### 5.3.3 HealthRouter类

**类型**：路由类
**职责**：定义健康检查相关的API路由

**路由方法**：
- **health_check**：健康检查接口
  - HTTP方法：GET
  - 路径：/api/v1/health
  - 响应：健康状态（JSON）
  - 逻辑：
    - 检查Redis连接（调用redis_client.ping）
    - 检查MySQL连接（调用mysql_client.query简单查询）
    - 检查ES连接（调用es_client.ping）
    - 检查Neo4j连接（执行简单Cypher查询）
    - 汇总状态
    - 返回JSON：{"status": "ok/degraded", "services": {...}}

**路由类之间关系**：
- ChatRouter、SessionRouter、HealthRouter相互独立
- 所有路由类都依赖对应的应用服务类（通过依赖注入）
- 路由类不包含业务逻辑，只负责HTTP层面的处理

---

## 6. 关键流程时序说明

### 6.1 ES查询完整流程

**参与对象**：
1. 用户
2. ChatRouter（API层）
3. ChatService（应用服务层）
4. SessionService（应用服务层）
5. ESIntentParser（领域逻辑层）
6. ESRetriever（领域逻辑层）
7. PromptBuilder（领域逻辑层）
8. KnowledgeMatcher（领域逻辑层）
9. LLMClient（基础设施层）
10. MessageRepository（基础设施层）
11. StreamingService（应用服务层）

**时序流程**：

第一步：用户发起POST请求到/api/v1/chat/stream，携带user_id、session_id和问题内容

第二步：ChatRouter接收请求，验证参数（使用Pydantic），从依赖容器获取ChatService实例

第三步：ChatRouter调用ChatService的handle_chat_stream方法，传入user_id、session_id、question、scene_id

第四步：ChatService根据scene_id判断为ES查询（scene_id=3），调用内部的es_flow方法

第五步：es_flow方法调用SessionService的get_messages方法，获取历史消息列表

第六步：SessionService调用MessageRepository的get_messages方法

第七步：MessageRepository先查询Redis，如果未命中则查询ES，返回历史消息列表给SessionService

第八步：SessionService返回历史消息给ChatService

第九步：ChatService调用StreamingService的stream_think_start方法，输出<think>标签开始，yield给用户

第十步：ChatService调用ESIntentParser的parse方法，传入question和history，开始意图解析

第十一步：ESIntentParser内部调用LLMClient的stream_chat方法，发送提示词给大模型

第十二步：LLMClient通过HTTP请求调用大模型API，以SSE格式接收响应

第十三步：LLMClient逐块返回解析结果，ESIntentParser通过回调函数将每块内容yield给用户（<think>内容）

第十四步：ESIntentParser完成解析，返回Intent对象给ChatService

第十五步：ChatService调用StreamingService的stream_think_end方法，输出</think>标签结束

第十六步：ChatService调用ESRetriever的retrieve方法，传入Intent对象

第十七步：ESRetriever调用EmbeddingClient获取查询向量

第十八步：ESRetriever调用KnowledgeRepository的search_hybrid方法（或其他检索方法）

第十九步：KnowledgeRepository调用ESClient执行ES查询，返回检索结果

第二十步：ESRetriever返回Knowledge对象列表给ChatService

第二十一步：ChatService调用PromptBuilder的build方法，传入question、history、knowledge_list

第二十二步：PromptBuilder格式化历史消息、格式化知识、拼接提示词模板，返回完整提示词

第二十三步：ChatService调用StreamingService的stream_data_start方法，输出<data>标签开始

第二十四步：ChatService调用LLMClient的stream_chat方法，传入完整提示词

第二十五步：LLMClient通过HTTP请求调用大模型API，以SSE格式接收生成的回答

第二十六步：LLMClient逐块返回回答内容，ChatService收集内容并通过StreamingService格式化后yield给用户

第二十七步：ChatService调用StreamingService的stream_data_end方法，输出</data>标签结束

第二十八步：ChatService调用KnowledgeMatcher的match方法，传入LLM完整输出和knowledge_list

第二十九步：KnowledgeMatcher使用BM25算法计算相似度，返回匹配的知识列表

第三十步：ChatService调用StreamingService的stream_knowledge方法，输出<knowledge>内容给用户

第三十一步：ChatService将保存消息的任务添加到后台任务队列（background_tasks）

第三十二步：后台任务异步执行，调用MessageRepository的save方法两次（保存用户消息和助手消息）

第三十三步：MessageRepository同时写入Redis和ES，完成消息持久化

第三十四步：流式响应结束，连接关闭

---

### 6.2 混合查询流程说明

**特点**：混合查询先执行Neo4j检索，再将Neo4j结果拼接到查询中，执行ES检索

**流程**：

前面步骤同ES查询流程（步骤一到步骤九）

第十步：ChatService调用IntentRoutingStrategy的route方法进行路由决策

第十一步：IntentRoutingStrategy调用LLM判断查询类型，返回"hybrid"

第十二步：ChatService输出路由决策结果："需要同时检索业务图谱和法规知识"

第十三步：ChatService调用StreamingService输出</think>标签

第十四步：ChatService调用HybridRetriever的retrieve方法

第十五步：HybridRetriever先调用Neo4jRetriever的retrieve方法

第十六步：Neo4jRetriever调用Neo4jIntentParser解析业务意图

第十七步：Neo4jRetriever根据意图构建Cypher查询

第十八步：Neo4jRetriever调用Neo4jClient执行Cypher查询，获取业务信息

第十九步：Neo4jRetriever格式化业务信息为Knowledge对象，返回给HybridRetriever

第二十步：HybridRetriever将业务信息拼接到原始查询中，形成增强查询

第二十一步：HybridRetriever创建新的Intent对象，query为增强查询

第二十二步：HybridRetriever调用ESRetriever的retrieve方法，传入增强Intent

第二十三步：ESRetriever执行ES检索（流程同ES查询流程的步骤十七到步骤二十）

第二十四步：HybridRetriever合并Neo4j和ES的检索结果，返回给ChatService

后续步骤同ES查询流程（构建Prompt → LLM生成 → 知识匹配 → 保存消息）

---

### 6.3 会话创建流程说明

**参与对象**：
1. 用户
2. SessionRouter（API层）
3. SessionService（应用服务层）
4. SessionRepository（基础设施层）
5. MySQLClient、RedisClient、ESClient（基础设施层）

**流程**：

第一步：用户发起POST请求到/api/v1/sessions，携带user_id和可选的name

第二步：SessionRouter接收请求，验证参数，从依赖容器获取SessionService实例

第三步：SessionRouter调用SessionService的create_session方法，传入user_id和name

第四步：SessionService创建Session对象（生成UUID作为session_id，设置created_at等）

第五步：SessionService调用SessionRepository的create方法，传入Session对象

第六步：SessionRepository生成完整的会话信息（包含所有元数据）

第七步：SessionRepository调用MySQLClient的execute方法，执行INSERT语句插入sessions表

第八步：MySQLClient返回执行结果（受影响的行数），SessionRepository确认写入成功

第九步：SessionRepository调用RedisClient的hset方法，将会话信息写入Hash（chat:{user_id}:sessions）

第十步：RedisClient返回操作结果，SessionRepository确认写入成功

第十一步：SessionRepository调用ESClient的index方法，将会话信息索引到conversation_history索引

第十二步：ESClient返回索引结果，SessionRepository确认写入成功

第十三步：SessionRepository返回session_id给SessionService

第十四步：SessionService返回session_id给SessionRouter

第十五步：SessionRouter构建SessionResponse对象，返回JSON响应给用户

---

### 6.4 消息存储流程说明（双层存储）

**参与对象**：
1. ChatService（应用服务层）
2. MessageRepository（基础设施层）
3. RedisClient、ESClient（基础设施层）

**流程**：

第一步：ChatService在后台任务中调用MessageRepository的save方法，传入user_id、session_id、role、content

第二步：MessageRepository构建消息对象（包含role、content、timestamp）

第三步：MessageRepository生成Redis的key（chat:{user_id}:session:{session_id}:messages）

第四步：MessageRepository将消息对象序列化为JSON字符串

第五步：MessageRepository调用RedisClient的rpush方法，将JSON字符串追加到List右侧

第六步：RedisClient执行RPUSH命令，返回List长度

第七步：MessageRepository调用RedisClient的llen方法，获取当前消息总数

第八步：MessageRepository构建ES文档（包含user_id、session_id、message_id、role、content、timestamp、message_order）

第九步：MessageRepository调用ESClient的index方法，将文档索引到conversation_history索引

第十步：ESClient执行索引操作，返回索引结果

第十一步：如果ES索引失败，MessageRepository记录错误日志，但不影响Redis写入（降级策略）

第十二步：MessageRepository返回（无返回值）

第十三步：后台任务完成

**关键点**：
- Redis和ES写入是并行的（都在save方法内）
- ES写入失败不影响Redis写入（允许最终一致性）
- Redis写入失败会抛出异常，影响整个操作

---

### 6.5 消息读取流程说明（Redis优先、ES备用）

**参与对象**：
1. SessionService（应用服务层）
2. MessageRepository（基础设施层）
3. RedisClient、ESClient（基础设施层）

**流程**：

第一步：SessionService调用MessageRepository的get_messages方法，传入user_id、session_id

第二步：MessageRepository生成Redis的key（chat:{user_id}:session:{session_id}:messages）

第三步：MessageRepository调用RedisClient的lrange方法，参数为key、0、-1（获取全部）

第四步：RedisClient执行LRANGE命令，返回JSON字符串列表

第五步：如果Redis返回了数据（列表非空）：
  - MessageRepository遍历列表，将每个JSON字符串反序列化为Message对象
  - MessageRepository返回Message对象列表给SessionService
  - 流程结束

第六步：如果Redis未返回数据（列表为空，缓存未命中）：
  - MessageRepository构建ES查询（按user_id和session_id过滤，按timestamp升序排序）
  - MessageRepository调用ESClient的search方法执行查询

第七步：ESClient返回查询结果（hits列表）

第八步：MessageRepository遍历hits，提取每条消息的字段（role、content、timestamp）

第九步：MessageRepository将提取的消息构建为Message对象列表

第十步：如果从ES获取到了消息（列表非空）：
  - MessageRepository遍历消息列表
  - 对每条消息调用RedisClient的rpush方法，回填到Redis
  - MessageRepository调用RedisClient的expire方法，设置key的过期时间为86400秒（24小时）
  - MessageRepository记录日志："从ES回填N条消息到Redis"

第十一步：MessageRepository返回Message对象列表给SessionService

**关键点**：
- 先查Redis（快速路径）
- Redis未命中才查ES（慢速路径）
- 从ES查到后回填Redis（缓存预热）
- 设置过期时间避免Redis无限增长

---

## 文档变更记录

| 版本 | 日期 | 作者 | 变更说明 |
|-----|------|------|---------|
| 2.0 | 2025-12-18 | hyy | 初始版本，纯文字详细设计 |

---

**相关文档**：
- 架构设计文档：`01-架构设计文档.md`
- 数据库设计文档：`03-数据库设计文档.md`
